{"ast":null,"code":"import _objectSpread from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { ref, getCurrentInstance, computed, unref, watch } from 'vue';\nimport { getRowIdentity, walkTreeNode } from '../util.mjs';\n\nfunction useTree(watcherData) {\n  var expandRowKeys = ref([]);\n  var treeData = ref({});\n  var indent = ref(16);\n  var lazy = ref(false);\n  var lazyTreeNodeMap = ref({});\n  var lazyColumnIdentifier = ref(\"hasChildren\");\n  var childrenColumnName = ref(\"children\");\n  var instance = getCurrentInstance();\n  var normalizedData = computed(function () {\n    if (!watcherData.rowKey.value) return {};\n    var data = watcherData.data.value || [];\n    return normalize(data);\n  });\n  var normalizedLazyNode = computed(function () {\n    var rowKey = watcherData.rowKey.value;\n    var keys = Object.keys(lazyTreeNodeMap.value);\n    var res = {};\n    if (!keys.length) return res;\n    keys.forEach(function (key) {\n      if (lazyTreeNodeMap.value[key].length) {\n        var item = {\n          children: []\n        };\n        lazyTreeNodeMap.value[key].forEach(function (row) {\n          var currentRowKey = getRowIdentity(row, rowKey);\n          item.children.push(currentRowKey);\n\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = {\n              children: []\n            };\n          }\n        });\n        res[key] = item;\n      }\n    });\n    return res;\n  });\n\n  var normalize = function normalize(data) {\n    var rowKey = watcherData.rowKey.value;\n    var res = {};\n    walkTreeNode(data, function (parent, children, level) {\n      var parentId = getRowIdentity(parent, rowKey);\n\n      if (Array.isArray(children)) {\n        res[parentId] = {\n          children: children.map(function (row) {\n            return getRowIdentity(row, rowKey);\n          }),\n          level: level\n        };\n      } else if (lazy.value) {\n        res[parentId] = {\n          children: [],\n          lazy: true,\n          level: level\n        };\n      }\n    }, childrenColumnName.value, lazyColumnIdentifier.value);\n    return res;\n  };\n\n  var updateTreeData = function updateTreeData() {\n    var ifChangeExpandRowKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var ifExpandAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_a) {\n      return (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value;\n    }();\n\n    var _a2;\n\n    var nested = normalizedData.value;\n    var normalizedLazyNode_ = normalizedLazyNode.value;\n    var keys = Object.keys(nested);\n    var newTreeData = {};\n\n    if (keys.length) {\n      var oldTreeData = unref(treeData);\n      var rootLazyRowKeys = [];\n\n      var getExpanded = function getExpanded(oldValue, key) {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key);\n          } else {\n            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));\n          }\n        } else {\n          var included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);\n          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);\n        }\n      };\n\n      keys.forEach(function (key) {\n        var oldValue = oldTreeData[key];\n\n        var newValue = _objectSpread({}, nested[key]);\n\n        newValue.expanded = getExpanded(oldValue, key);\n\n        if (newValue.lazy) {\n          var _ref = oldValue || {},\n              _ref$loaded = _ref.loaded,\n              loaded = _ref$loaded === void 0 ? false : _ref$loaded,\n              _ref$loading = _ref.loading,\n              loading = _ref$loading === void 0 ? false : _ref$loading;\n\n          newValue.loaded = !!loaded;\n          newValue.loading = !!loading;\n          rootLazyRowKeys.push(key);\n        }\n\n        newTreeData[key] = newValue;\n      });\n      var lazyKeys = Object.keys(normalizedLazyNode_);\n\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach(function (key) {\n          var oldValue = oldTreeData[key];\n          var lazyNodeChildren = normalizedLazyNode_[key].children;\n\n          if (rootLazyRowKeys.includes(key)) {\n            if (newTreeData[key].children.length !== 0) {\n              throw new Error(\"[ElTable]children must be an empty array.\");\n            }\n\n            newTreeData[key].children = lazyNodeChildren;\n          } else {\n            var _ref2 = oldValue || {},\n                _ref2$loaded = _ref2.loaded,\n                loaded = _ref2$loaded === void 0 ? false : _ref2$loaded,\n                _ref2$loading = _ref2.loading,\n                loading = _ref2$loading === void 0 ? false : _ref2$loading;\n\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: \"\"\n            };\n          }\n        });\n      }\n    }\n\n    treeData.value = newTreeData;\n    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();\n  };\n\n  watch(function () {\n    return expandRowKeys.value;\n  }, function () {\n    updateTreeData(true);\n  });\n  watch(function () {\n    return normalizedData.value;\n  }, function () {\n    updateTreeData();\n  });\n  watch(function () {\n    return normalizedLazyNode.value;\n  }, function () {\n    updateTreeData();\n  });\n\n  var updateTreeExpandKeys = function updateTreeExpandKeys(value) {\n    expandRowKeys.value = value;\n    updateTreeData();\n  };\n\n  var toggleTreeExpansion = function toggleTreeExpansion(row, expanded) {\n    instance.store.assertRowKey();\n    var rowKey = watcherData.rowKey.value;\n    var id = getRowIdentity(row, rowKey);\n    var data = id && treeData.value[id];\n\n    if (id && data && \"expanded\" in data) {\n      var oldExpanded = data.expanded;\n      expanded = typeof expanded === \"undefined\" ? !data.expanded : expanded;\n      treeData.value[id].expanded = expanded;\n\n      if (oldExpanded !== expanded) {\n        instance.emit(\"expand-change\", row, expanded);\n      }\n\n      instance.store.updateTableScrollY();\n    }\n  };\n\n  var loadOrToggle = function loadOrToggle(row) {\n    instance.store.assertRowKey();\n    var rowKey = watcherData.rowKey.value;\n    var id = getRowIdentity(row, rowKey);\n    var data = treeData.value[id];\n\n    if (lazy.value && data && \"loaded\" in data && !data.loaded) {\n      loadData(row, id, data);\n    } else {\n      toggleTreeExpansion(row, void 0);\n    }\n  };\n\n  var loadData = function loadData(row, key, treeNode) {\n    var load = instance.props.load;\n\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true;\n      load(row, treeNode, function (data) {\n        if (!Array.isArray(data)) {\n          throw new TypeError(\"[ElTable] data must be an array\");\n        }\n\n        treeData.value[key].loading = false;\n        treeData.value[key].loaded = true;\n        treeData.value[key].expanded = true;\n\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data;\n        }\n\n        instance.emit(\"expand-change\", row, true);\n      });\n    }\n  };\n\n  return {\n    loadData: loadData,\n    loadOrToggle: loadOrToggle,\n    toggleTreeExpansion: toggleTreeExpansion,\n    updateTreeExpandKeys: updateTreeExpandKeys,\n    updateTreeData: updateTreeData,\n    normalize: normalize,\n    states: {\n      expandRowKeys: expandRowKeys,\n      treeData: treeData,\n      indent: indent,\n      lazy: lazy,\n      lazyTreeNodeMap: lazyTreeNodeMap,\n      lazyColumnIdentifier: lazyColumnIdentifier,\n      childrenColumnName: childrenColumnName\n    }\n  };\n}\n\nexport { useTree as default };","map":{"version":3,"mappings":"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","names":["useTree","watcherData","expandRowKeys","ref","treeData","indent","lazy","lazyTreeNodeMap","lazyColumnIdentifier","childrenColumnName","instance","getCurrentInstance","normalizedData","computed","rowKey","value","data","normalize","normalizedLazyNode","keys","Object","res","length","forEach","key","item","children","row","currentRowKey","getRowIdentity","push","walkTreeNode","parent","level","parentId","Array","isArray","map","updateTreeData","ifChangeExpandRowKeys","ifExpandAll","_a","store","states","defaultExpandAll","_a2","nested","normalizedLazyNode_","newTreeData","oldTreeData","unref","rootLazyRowKeys","getExpanded","oldValue","includes","expanded","included","newValue","loaded","loading","lazyKeys","lazyNodeChildren","Error","updateTableScrollY","watch","updateTreeExpandKeys","toggleTreeExpansion","assertRowKey","id","oldExpanded","emit","loadOrToggle","loadData","treeNode","load","props","TypeError"],"sources":["../../../../../../../packages/components/table/src/store/tree.ts"],"sourcesContent":["import { computed, getCurrentInstance, ref, unref, watch } from 'vue'\nimport { getRowIdentity, walkTreeNode } from '../util'\n\nimport type { WatcherPropsData } from '.'\nimport type { Table, TableProps } from '../table/defaults'\n\nfunction useTree<T>(watcherData: WatcherPropsData<T>) {\n  const expandRowKeys = ref<string[]>([])\n  const treeData = ref<unknown>({})\n  const indent = ref(16)\n  const lazy = ref(false)\n  const lazyTreeNodeMap = ref({})\n  const lazyColumnIdentifier = ref('hasChildren')\n  const childrenColumnName = ref('children')\n  const instance = getCurrentInstance() as Table<T>\n  const normalizedData = computed(() => {\n    if (!watcherData.rowKey.value) return {}\n    const data = watcherData.data.value || []\n    return normalize(data)\n  })\n  const normalizedLazyNode = computed(() => {\n    const rowKey = watcherData.rowKey.value\n    const keys = Object.keys(lazyTreeNodeMap.value)\n    const res = {}\n    if (!keys.length) return res\n    keys.forEach((key) => {\n      if (lazyTreeNodeMap.value[key].length) {\n        const item = { children: [] }\n        lazyTreeNodeMap.value[key].forEach((row) => {\n          const currentRowKey = getRowIdentity(row, rowKey)\n          item.children.push(currentRowKey)\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = { children: [] }\n          }\n        })\n        res[key] = item\n      }\n    })\n    return res\n  })\n\n  const normalize = (data) => {\n    const rowKey = watcherData.rowKey.value\n    const res = {}\n    walkTreeNode(\n      data,\n      (parent, children, level) => {\n        const parentId = getRowIdentity(parent, rowKey)\n        if (Array.isArray(children)) {\n          res[parentId] = {\n            children: children.map((row) => getRowIdentity(row, rowKey)),\n            level,\n          }\n        } else if (lazy.value) {\n          // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点\n          res[parentId] = {\n            children: [],\n            lazy: true,\n            level,\n          }\n        }\n      },\n      childrenColumnName.value,\n      lazyColumnIdentifier.value\n    )\n    return res\n  }\n\n  const updateTreeData = (\n    ifChangeExpandRowKeys = false,\n    ifExpandAll = instance.store?.states.defaultExpandAll.value\n  ) => {\n    const nested = normalizedData.value\n    const normalizedLazyNode_ = normalizedLazyNode.value\n    const keys = Object.keys(nested)\n    const newTreeData = {}\n    if (keys.length) {\n      const oldTreeData = unref(treeData)\n      const rootLazyRowKeys = []\n      const getExpanded = (oldValue, key) => {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key)\n          } else {\n            return !!(ifExpandAll || oldValue?.expanded)\n          }\n        } else {\n          const included =\n            ifExpandAll ||\n            (expandRowKeys.value && expandRowKeys.value.includes(key))\n          return !!(oldValue?.expanded || included)\n        }\n      }\n      // 合并 expanded 与 display，确保数据刷新后，状态不变\n      keys.forEach((key) => {\n        const oldValue = oldTreeData[key]\n        const newValue = { ...nested[key] }\n        newValue.expanded = getExpanded(oldValue, key)\n        if (newValue.lazy) {\n          const { loaded = false, loading = false } = oldValue || {}\n          newValue.loaded = !!loaded\n          newValue.loading = !!loading\n          rootLazyRowKeys.push(key)\n        }\n        newTreeData[key] = newValue\n      })\n      // 根据懒加载数据更新 treeData\n      const lazyKeys = Object.keys(normalizedLazyNode_)\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach((key) => {\n          const oldValue = oldTreeData[key]\n          const lazyNodeChildren = normalizedLazyNode_[key].children\n          if (rootLazyRowKeys.includes(key)) {\n            // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组\n            if (newTreeData[key].children.length !== 0) {\n              throw new Error('[ElTable]children must be an empty array.')\n            }\n            newTreeData[key].children = lazyNodeChildren\n          } else {\n            const { loaded = false, loading = false } = oldValue || {}\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: '',\n            }\n          }\n        })\n      }\n    }\n    treeData.value = newTreeData\n    instance.store?.updateTableScrollY()\n  }\n\n  watch(\n    () => expandRowKeys.value,\n    () => {\n      updateTreeData(true)\n    }\n  )\n\n  watch(\n    () => normalizedData.value,\n    () => {\n      updateTreeData()\n    }\n  )\n  watch(\n    () => normalizedLazyNode.value,\n    () => {\n      updateTreeData()\n    }\n  )\n\n  const updateTreeExpandKeys = (value: string[]) => {\n    expandRowKeys.value = value\n    updateTreeData()\n  }\n\n  const toggleTreeExpansion = (row: T, expanded?: boolean) => {\n    instance.store.assertRowKey()\n\n    const rowKey = watcherData.rowKey.value\n    const id = getRowIdentity(row, rowKey)\n    const data = id && treeData.value[id]\n    if (id && data && 'expanded' in data) {\n      const oldExpanded = data.expanded\n      expanded = typeof expanded === 'undefined' ? !data.expanded : expanded\n      treeData.value[id].expanded = expanded\n      if (oldExpanded !== expanded) {\n        instance.emit('expand-change', row, expanded)\n      }\n      instance.store.updateTableScrollY()\n    }\n  }\n\n  const loadOrToggle = (row) => {\n    instance.store.assertRowKey()\n    const rowKey = watcherData.rowKey.value\n    const id = getRowIdentity(row, rowKey)\n    const data = treeData.value[id]\n    if (lazy.value && data && 'loaded' in data && !data.loaded) {\n      loadData(row, id, data)\n    } else {\n      toggleTreeExpansion(row, undefined)\n    }\n  }\n\n  const loadData = (row: T, key: string, treeNode) => {\n    const { load } = instance.props as unknown as TableProps<T>\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true\n      load(row, treeNode, (data) => {\n        if (!Array.isArray(data)) {\n          throw new TypeError('[ElTable] data must be an array')\n        }\n        treeData.value[key].loading = false\n        treeData.value[key].loaded = true\n        treeData.value[key].expanded = true\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data\n        }\n        instance.emit('expand-change', row, true)\n      })\n    }\n  }\n\n  return {\n    loadData,\n    loadOrToggle,\n    toggleTreeExpansion,\n    updateTreeExpandKeys,\n    updateTreeData,\n    normalize,\n    states: {\n      expandRowKeys,\n      treeData,\n      indent,\n      lazy,\n      lazyTreeNodeMap,\n      lazyColumnIdentifier,\n      childrenColumnName,\n    },\n  }\n}\n\nexport default useTree\n"]},"metadata":{},"sourceType":"module"}