{"ast":null,"code":"import _typeof from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport '../../../../utils/index.mjs';\nimport createGrid from '../builders/build-grid.mjs';\nimport { AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { isNumber } from '@vueuse/core';\nimport { throwError } from '../../../../utils/error.mjs';\nvar SCOPE = \"ElFixedSizeGrid\";\nvar FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: function getColumnPosition(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return [columnWidth, index * columnWidth];\n  },\n  getRowPosition: function getRowPosition(_ref2, index) {\n    var rowHeight = _ref2.rowHeight;\n    return [rowHeight, index * rowHeight];\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref3) {\n    var totalRow = _ref3.totalRow,\n        rowHeight = _ref3.rowHeight;\n    return rowHeight * totalRow;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref4) {\n    var totalColumn = _ref4.totalColumn,\n        columnWidth = _ref4.columnWidth;\n    return columnWidth * totalColumn;\n  },\n  getColumnOffset: function getColumnOffset(_ref5, columnIndex, alignment, scrollLeft, _, scrollBarWidth) {\n    var totalColumn = _ref5.totalColumn,\n        columnWidth = _ref5.columnWidth,\n        width = _ref5.width;\n    width = Number(width);\n    var lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        {\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(width / 2)) {\n            return 0;\n          } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n            return lastColumnOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getRowOffset: function getRowOffset(_ref6, rowIndex, align, scrollTop, _, scrollBarWidth) {\n    var rowHeight = _ref6.rowHeight,\n        height = _ref6.height,\n        totalRow = _ref6.totalRow;\n    height = Number(height);\n    var lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        {\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(height / 2)) {\n            return 0;\n          } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n            return lastRowOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref7, scrollLeft) {\n    var columnWidth = _ref7.columnWidth,\n        totalColumn = _ref7.totalColumn;\n    return Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref8, startIndex, scrollLeft) {\n    var columnWidth = _ref8.columnWidth,\n        totalColumn = _ref8.totalColumn,\n        width = _ref8.width;\n    var left = startIndex * columnWidth;\n    var visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref9, scrollTop) {\n    var rowHeight = _ref9.rowHeight,\n        totalRow = _ref9.totalRow;\n    return Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref10, startIndex, scrollTop) {\n    var rowHeight = _ref10.rowHeight,\n        totalRow = _ref10.totalRow,\n        height = _ref10.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: function initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps: function validateProps(_ref11) {\n    var columnWidth = _ref11.columnWidth,\n        rowHeight = _ref11.rowHeight;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as number,\\n            instead \".concat(_typeof(columnWidth), \" was given.\\n        \"));\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as number,\\n            instead \".concat(_typeof(rowHeight), \" was given.\\n        \"));\n      }\n    }\n  }\n});\nexport { FixedSizeGrid as default };","map":{"version":3,"mappings":"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","names":["SCOPE","FixedSizeGrid","createGrid","name","getColumnPosition","index","columnWidth","getRowPosition","rowHeight","getEstimatedTotalHeight","totalRow","getEstimatedTotalWidth","totalColumn","getColumnOffset","columnIndex","alignment","scrollLeft","_","scrollBarWidth","width","Number","lastColumnOffset","Math","max","maxOffset","min","minOffset","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getRowOffset","rowIndex","align","scrollTop","height","lastRowOffset","SMART_ALIGNMENT","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","left","visibleColumnsCount","getRowStartIndexForOffset","getRowStopIndexForStartIndex","top","numVisibleRows","initCache","clearCache","validateProps","process","env","NODE_ENV","isNumber","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-grid.ts"],"sourcesContent":["import { isNumber, throwError } from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nconst SCOPE = 'ElFixedSizeGrid'\n\nconst FixedSizeGrid = createGrid({\n  name: 'ElFixedSizeGrid',\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth as number,\n    index * (columnWidth as number),\n  ],\n\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight as number,\n    index * (rowHeight as number),\n  ],\n\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) =>\n    (rowHeight as number) * totalRow,\n\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) =>\n    (columnWidth as number) * totalColumn,\n\n  getColumnOffset: (\n    { totalColumn, columnWidth, width },\n    columnIndex,\n    alignment,\n    scrollLeft,\n    _,\n    scrollBarWidth\n  ) => {\n    width = Number(width)\n    const lastColumnOffset = Math.max(\n      0,\n      totalColumn * (columnWidth as number) - width\n    )\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * (columnWidth as number)\n    )\n    const minOffset = Math.max(\n      0,\n      columnIndex * (columnWidth as number) -\n        width +\n        scrollBarWidth +\n        (columnWidth as number)\n    )\n\n    if (alignment === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollLeft < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getRowOffset: (\n    { rowHeight, height, totalRow },\n    rowIndex,\n    align,\n    scrollTop,\n    _,\n    scrollBarWidth\n  ): number => {\n    height = Number(height)\n    const lastRowOffset = Math.max(0, totalRow * (rowHeight as number) - height)\n    const maxOffset = Math.min(lastRowOffset, rowIndex * (rowHeight as number))\n    const minOffset = Math.max(\n      0,\n      rowIndex * (rowHeight as number) -\n        height +\n        scrollBarWidth +\n        (rowHeight as number)\n    )\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT\n      } else {\n        align = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollTop < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) =>\n    Math.max(\n      0,\n      Math.min(\n        totalColumn - 1,\n        Math.floor(scrollLeft / (columnWidth as number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, totalColumn, width },\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * (columnWidth as number)\n    const visibleColumnsCount = Math.ceil(\n      ((width as number) + scrollLeft - left) / (columnWidth as number)\n    )\n    return Math.max(\n      0,\n      Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1)\n    )\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, totalRow },\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(totalRow - 1, Math.floor(scrollTop / (rowHeight as number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, totalRow, height },\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * (rowHeight as number)\n    const numVisibleRows = Math.ceil(\n      ((height as number) + scrollTop - top) / (rowHeight as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        totalRow - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    )\n  },\n  /**\n   * Fixed size grid does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache: () => undefined as any,\n\n  clearCache: true,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isNumber(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default FixedSizeGrid\n"]},"metadata":{},"sourceType":"module"}