{"ast":null,"code":"import '../../../../utils/index.mjs';\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT } from '../defaults.mjs';\nimport { isString } from '@vue/shared';\nimport { throwError } from '../../../../utils/error.mjs';\nvar FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var total = _ref3.total,\n        itemSize = _ref3.itemSize;\n    return itemSize * total;\n  },\n  getOffset: function getOffset(_ref4, index, alignment, scrollOffset) {\n    var height = _ref4.height,\n        total = _ref4.total,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    var size = isHorizontal(layout) ? width : height;\n\n    if (process.env.NODE_ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", \"\\n        You should set\\n          width/height\\n        to number when your layout is\\n          horizontal/vertical\\n      \");\n    }\n\n    var lastItemOffset = Math.max(0, total * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, (index + 1) * itemSize - size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var total = _ref5.total,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var height = _ref6.height,\n        total = _ref6.total,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    var offset = startIndex * itemSize;\n    var size = isHorizontal(layout) ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache: function initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps: function validateProps() {}\n});\nexport { FixedSizeList as default };","map":{"version":3,"mappings":"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","names":["FixedSizeList","buildList","name","getItemOffset","index","itemSize","getItemSize","getEstimatedTotalSize","total","getOffset","alignment","scrollOffset","height","layout","width","size","isHorizontal","process","env","NODE_ENV","isString","throwError","lastItemOffset","Math","max","maxOffset","min","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getStartIndexForOffset","offset","getStopIndexForStartIndex","startIndex","numVisibleItems","initCache","clearCache","validateProps"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-list.ts"],"sourcesContent":["import { isString, throwError } from '@element-plus/utils'\nimport buildList from '../builders/build-list'\nimport { isHorizontal } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nimport type { VirtualizedListProps } from '../props'\n\ntype Props = VirtualizedListProps\n\nconst FixedSizeList = buildList({\n  name: 'ElFixedSizeList',\n  getItemOffset: ({ itemSize }, index) => index * (itemSize as number),\n\n  getItemSize: ({ itemSize }) => itemSize as number,\n\n  getEstimatedTotalSize: ({ total, itemSize }) => (itemSize as number) * total,\n\n  getOffset: (\n    { height, total, itemSize, layout, width },\n    index,\n    alignment,\n    scrollOffset\n  ) => {\n    const size = (isHorizontal(layout) ? width : height) as number\n    if (process.env.NODE_ENV !== 'production' && isString(size)) {\n      throwError(\n        '[ElVirtualList]',\n        `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `\n      )\n    }\n    const lastItemOffset = Math.max(0, total * (itemSize as number) - size)\n    const maxOffset = Math.min(lastItemOffset, index * (itemSize as number))\n    const minOffset = Math.max(0, (index + 1) * (itemSize as number) - size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0 // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset // near the end\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: ({ total, itemSize }, offset) =>\n    Math.max(0, Math.min(total - 1, Math.floor(offset / (itemSize as number)))),\n\n  getStopIndexForStartIndex: (\n    { height, total, itemSize, layout, width }: Props,\n    startIndex: number,\n    scrollOffset: number\n  ) => {\n    const offset = startIndex * (itemSize as number)\n    const size = isHorizontal(layout) ? width : height\n    const numVisibleItems = Math.ceil(\n      ((size as number) + scrollOffset - offset) / (itemSize as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        total - 1,\n        // because startIndex is inclusive, so in order to prevent array outbound indexing\n        // we need to - 1 to prevent outbound behavior\n        startIndex + numVisibleItems - 1\n      )\n    )\n  },\n\n  /**\n   * Fixed size list does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache() {\n    return undefined as any\n  },\n\n  clearCache: true,\n\n  validateProps() {\n    //\n  },\n})\n\nexport default FixedSizeList\n"]},"metadata":{},"sourceType":"module"}