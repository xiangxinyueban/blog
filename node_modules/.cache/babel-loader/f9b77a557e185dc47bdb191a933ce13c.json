{"ast":null,"code":"import _objectSpread from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport { toRefs, computed, nextTick } from 'vue';\nimport { pick } from 'lodash-unified';\nimport { ElSelect } from '../../select/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\n\nvar useSelect = function useSelect(props, _ref, _ref2) {\n  var attrs = _ref.attrs;\n  var tree = _ref2.tree,\n      key = _ref2.key;\n  var ns = useNamespace(\"tree-select\");\n\n  var result = _objectSpread(_objectSpread(_objectSpread({}, pick(toRefs(props), Object.keys(ElSelect.props))), attrs), {}, {\n    valueKey: key,\n    popperClass: computed(function () {\n      var classes = [ns.e(\"popper\")];\n      if (props.popperClass) classes.push(props.popperClass);\n      return classes.join(\" \");\n    }),\n    filterMethod: function filterMethod() {\n      var keyword = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      if (props.filterMethod) props.filterMethod(keyword);\n      nextTick(function () {\n        var _a;\n\n        (_a = tree.value) == null ? void 0 : _a.filter(keyword);\n      });\n    },\n    onVisibleChange: function onVisibleChange(visible) {\n      var _a;\n\n      (_a = attrs.onVisibleChange) == null ? void 0 : _a.call(attrs, visible);\n\n      if (props.filterable && visible) {\n        result.filterMethod();\n      }\n    }\n  });\n\n  return result;\n};\n\nexport { useSelect };","map":{"version":3,"mappings":";;;;;;;;;;;AAIY,IAACA,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,eAGnB;AAAA,MAH6BC,KAG7B,QAH6BA,KAG7B;AAAA,MAFJC,IAEI,SAFJA,IAEI;AAAA,MADJC,GACI,SADJA,GACI;AACJ,MAAMC,EAAE,GAAGC,YAAY,CAAC,aAAD,CAAvB;;AACA,MAAMC,MAAM,iDACPC,IAAI,CAACC,MAAM,CAACR,KAAD,CAAP,EAAgBS,MAAM,CAACC,IAAP,CAAYC,QAAQ,CAACX,KAArB,CAAhB,CADG,GAEPC,KAFO;AAGVW,YAAQ,EAAET,GAHA;AAIVU,eAAW,EAAEC,QAAQ,CAAC,YAAM;AAC1B,UAAMC,OAAO,GAAG,CAACX,EAAE,CAACY,CAAH,CAAK,QAAL,CAAD,CAAhB;AACA,UAAIhB,KAAK,CAACa,WAAV,EACEE,OAAO,CAACE,IAAR,CAAajB,KAAK,CAACa,WAAnB;AACF,aAAOE,OAAO,CAACG,IAAR,CAAa,GAAb,CAAP;AACD,KALoB,CAJX;AAUVC,gBAAY,EAAE,wBAAkB;AAAA,UAAjBC,OAAiB,uEAAP,EAAO;AAC9B,UAAIpB,KAAK,CAACmB,YAAV,EACEnB,KAAK,CAACmB,YAAN,CAAmBC,OAAnB;AACFC,cAAQ,CAAC,YAAM;AACb,YAAIC,EAAJ;;AACA,SAACA,EAAE,GAAGpB,IAAI,CAACqB,KAAX,KAAqB,IAArB,GAA4B,KAAK,CAAjC,GAAqCD,EAAE,CAACE,MAAH,CAAUJ,OAAV,CAArC;AACD,OAHO,CAAR;AAID,KAjBS;AAkBVK,mBAAe,EAAE,yBAACC,OAAD,EAAa;AAC5B,UAAIJ,EAAJ;;AACA,OAACA,EAAE,GAAGrB,KAAK,CAACwB,eAAZ,KAAgC,IAAhC,GAAuC,KAAK,CAA5C,GAAgDH,EAAE,CAACK,IAAH,CAAQ1B,KAAR,EAAeyB,OAAf,CAAhD;;AACA,UAAI1B,KAAK,CAAC4B,UAAN,IAAoBF,OAAxB,EAAiC;AAC/BpB,cAAM,CAACa,YAAP;AACD;AACF;AAxBS,IAAZ;;AA0BA,SAAOb,MAAP;AACF,CAhCY","names":["useSelect","props","attrs","tree","key","ns","useNamespace","result","pick","toRefs","Object","keys","ElSelect","valueKey","popperClass","computed","classes","e","push","join","filterMethod","keyword","nextTick","_a","value","filter","onVisibleChange","visible","call","filterable"],"sources":["../../../../../../packages/components/tree-select/src/select.ts"],"sourcesContent":["import { computed, nextTick, toRefs } from 'vue'\nimport { pick } from 'lodash-unified'\nimport ElSelect from '@element-plus/components/select'\nimport { useNamespace } from '@element-plus/hooks'\nimport type { Ref } from 'vue'\nimport type ElTree from '@element-plus/components/tree'\n\nexport const useSelect = (\n  props,\n  { attrs },\n  {\n    tree,\n    key,\n  }: {\n    select: Ref<InstanceType<typeof ElSelect> | undefined>\n    tree: Ref<InstanceType<typeof ElTree> | undefined>\n    key: Ref<string>\n  }\n) => {\n  const ns = useNamespace('tree-select')\n\n  const result = {\n    ...pick(toRefs(props), Object.keys(ElSelect.props)),\n    ...attrs,\n    valueKey: key,\n    popperClass: computed(() => {\n      const classes = [ns.e('popper')]\n      if (props.popperClass) classes.push(props.popperClass)\n      return classes.join(' ')\n    }),\n    filterMethod: (keyword = '') => {\n      if (props.filterMethod) props.filterMethod(keyword)\n\n      nextTick(() => {\n        // let tree node expand only, same with tree filter\n        tree.value?.filter(keyword)\n      })\n    },\n    // clear filter text when visible change\n    onVisibleChange: (visible: boolean) => {\n      attrs.onVisibleChange?.(visible)\n\n      if (props.filterable && visible) {\n        result.filterMethod()\n      }\n    },\n  }\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}