{"ast":null,"code":"import _toConsumableArray from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\n\nvar obtainAllFocusableElements = function obtainAllFocusableElements(element) {\n  var nodes = [];\n  var walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: function acceptNode(node) {\n      var isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) {\n    nodes.push(walker.currentNode);\n  }\n\n  return nodes;\n};\n\nvar getVisibleElement = function getVisibleElement(elements, container) {\n  var _iterator = _createForOfIteratorHelper(elements),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var element = _step.value;\n      if (!isHidden(element, container)) return element;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nvar isHidden = function isHidden(element, container) {\n  if (process.env.NODE_ENV === \"test\") return false;\n  if (getComputedStyle(element).visibility === \"hidden\") return true;\n\n  while (element) {\n    if (container && element === container) return false;\n    if (getComputedStyle(element).display === \"none\") return true;\n    element = element.parentElement;\n  }\n\n  return false;\n};\n\nvar getEdges = function getEdges(container) {\n  var focusable = obtainAllFocusableElements(container);\n  var first = getVisibleElement(focusable, container);\n  var last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\n\nvar isSelectable = function isSelectable(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\n\nvar tryFocus = function tryFocus(element, shouldSelect) {\n  if (element && element.focus) {\n    var prevFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\n\nfunction removeFromStack(list, item) {\n  var copy = _toConsumableArray(list);\n\n  var idx = list.indexOf(item);\n\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n\n  return copy;\n}\n\nvar createFocusableStack = function createFocusableStack() {\n  var stack = [];\n\n  var push = function push(layer) {\n    var currentLayer = stack[0];\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n\n  var remove = function remove(layer) {\n    var _a, _b;\n\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n\n  return {\n    push: push,\n    remove: remove\n  };\n};\n\nvar focusFirstDescendant = function focusFirstDescendant(elements) {\n  var shouldSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var prevFocusedElement = document.activeElement;\n\n  var _iterator2 = _createForOfIteratorHelper(elements),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var element = _step2.value;\n      tryFocus(element, shouldSelect);\n      if (document.activeElement !== prevFocusedElement) return;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\nvar focusableStack = createFocusableStack();\nexport { focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isHidden, obtainAllFocusableElements, tryFocus };","map":{"version":3,"mappings":"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","names":["obtainAllFocusableElements","element","nodes","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","FILTER_ACCEPT","nextNode","push","currentNode","getVisibleElement","elements","container","isHidden","process","env","NODE_ENV","getComputedStyle","visibility","display","parentElement","getEdges","focusable","first","last","reverse","isSelectable","HTMLInputElement","tryFocus","shouldSelect","focus","prevFocusedElement","activeElement","preventScroll","select","removeFromStack","list","item","copy","idx","indexOf","splice","createFocusableStack","stack","layer","currentLayer","pause","unshift","remove","_a","_b","resume","call","focusFirstDescendant","focusableStack"],"sources":["../../../../../../packages/components/focus-trap/src/utils.ts"],"sourcesContent":["export type FocusLayer = {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nexport type FocusStack = FocusLayer[]\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (\n      node: Element & {\n        disabled: boolean\n        hidden: boolean\n        type: string\n        tabIndex: number\n      }\n    ) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      return node.tabIndex >= 0\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n\n  return nodes\n}\n\nexport const getVisibleElement = (\n  elements: HTMLElement[],\n  container: HTMLElement\n) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element\n  }\n}\n\nexport const isHidden = (element: HTMLElement, container: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return false\n  if (getComputedStyle(element).visibility === 'hidden') return true\n\n  while (element) {\n    if (container && element === container) return false\n    if (getComputedStyle(element).display === 'none') return true\n    element = element.parentElement as HTMLElement\n  }\n\n  return false\n}\n\nexport const getEdges = (container: HTMLElement) => {\n  const focusable = obtainAllFocusableElements(container)\n  const first = getVisibleElement(focusable, container)\n  const last = getVisibleElement(focusable.reverse(), container)\n  return [first, last]\n}\n\nconst isSelectable = (\n  element: any\n): element is HTMLInputElement & { select: () => void } => {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport const tryFocus = (\n  element?: HTMLElement | { focus: () => void } | null,\n  shouldSelect?: boolean\n) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement\n    element.focus({ preventScroll: true })\n    if (\n      element !== prevFocusedElement &&\n      isSelectable(element) &&\n      shouldSelect\n    ) {\n      element.select()\n    }\n  }\n}\n\nfunction removeFromStack<T>(list: T[], item: T) {\n  const copy = [...list]\n\n  const idx = list.indexOf(item)\n\n  if (idx !== -1) {\n    copy.splice(idx, 1)\n  }\n  return copy\n}\n\nconst createFocusableStack = () => {\n  let stack = [] as FocusStack\n\n  const push = (layer: FocusLayer) => {\n    const currentLayer = stack[0]\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause()\n    }\n\n    stack = removeFromStack(stack, layer)\n    stack.unshift(layer)\n  }\n\n  const remove = (layer: FocusLayer) => {\n    stack = removeFromStack(stack, layer)\n    stack[0]?.resume?.()\n  }\n\n  return {\n    push,\n    remove,\n  }\n}\n\nexport const focusFirstDescendant = (\n  elements: HTMLElement[],\n  shouldSelect = false\n) => {\n  const prevFocusedElement = document.activeElement\n  for (const element of elements) {\n    tryFocus(element, shouldSelect)\n    if (document.activeElement !== prevFocusedElement) return\n  }\n}\n\nexport const focusableStack = createFocusableStack()\n"]},"metadata":{},"sourceType":"module"}