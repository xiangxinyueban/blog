{"ast":null,"code":"import _slicedToArray from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport { warn } from 'vue';\nimport { fromPairs } from 'lodash-unified';\nimport '../types.mjs';\nimport '../objects.mjs';\nimport { isObject, hasOwn } from '@vue/shared';\nvar wrapperKey = Symbol();\nvar propKey = \"__elPropsReservedKey\";\n\nfunction buildProp(option, key) {\n  if (!isObject(option) || !!option[propKey]) return option;\n  var values = option.values,\n      required = option.required,\n      defaultValue = option[\"default\"],\n      type = option.type,\n      validator = option.validator;\n\n  var _validator = values || validator ? function (val) {\n    var valid = false;\n    var allowedValues = [];\n\n    if (values) {\n      allowedValues = Array.from(values);\n\n      if (hasOwn(option, \"default\")) {\n        allowedValues.push(defaultValue);\n      }\n\n      valid || (valid = allowedValues.includes(val));\n    }\n\n    if (validator) valid || (valid = validator(val));\n\n    if (!valid && allowedValues.length > 0) {\n      var allowValuesText = _toConsumableArray(new Set(allowedValues)).map(function (value) {\n        return JSON.stringify(value);\n      }).join(\", \");\n\n      warn(\"Invalid prop: validation failed\".concat(key ? \" for prop \\\"\".concat(key, \"\\\"\") : \"\", \". Expected one of [\").concat(allowValuesText, \"], got value \").concat(JSON.stringify(val), \".\"));\n    }\n\n    return valid;\n  } : void 0;\n\n  var prop = _defineProperty({\n    type: isObject(type) && Object.getOwnPropertySymbols(type).includes(wrapperKey) ? type[wrapperKey] : type,\n    required: !!required,\n    validator: _validator\n  }, propKey, true);\n\n  if (hasOwn(option, \"default\")) prop[\"default\"] = defaultValue;\n  return prop;\n}\n\nvar buildProps = function buildProps(props) {\n  return fromPairs(Object.entries(props).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        option = _ref2[1];\n\n    return [key, buildProp(option, key)];\n  }));\n};\n\nvar definePropType = function definePropType(val) {\n  return _defineProperty({}, wrapperKey, val);\n};\n\nexport { buildProp, buildProps, definePropType, propKey };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAIA,IAAMA,UAAU,GAAGC,MAAM,EAAzB;AACY,IAACC,OAAO,GAAG,sBAAX;;AACL,SAASC,SAAT,CAAmBC,MAAnB,EAA2BC,GAA3B,EAAgC;AACrC,MAAI,CAACC,QAAQ,CAACF,MAAD,CAAT,IAAqB,CAAC,CAACA,MAAM,CAACF,OAAD,CAAjC,EACE,OAAOE,MAAP;AACF,MAAQG,MAAR,GAAqEH,MAArE,CAAQG,MAAR;AAAA,MAAgBC,QAAhB,GAAqEJ,MAArE,CAAgBI,QAAhB;AAAA,MAAmCC,YAAnC,GAAqEL,MAArE;AAAA,MAAiDM,IAAjD,GAAqEN,MAArE,CAAiDM,IAAjD;AAAA,MAAuDC,SAAvD,GAAqEP,MAArE,CAAuDO,SAAvD;;AACA,MAAMC,UAAU,GAAGL,MAAM,IAAII,SAAV,GAAsB,UAACE,GAAD,EAAS;AAChD,QAAIC,KAAK,GAAG,KAAZ;AACA,QAAIC,aAAa,GAAG,EAApB;;AACA,QAAIR,MAAJ,EAAY;AACVQ,mBAAa,GAAGC,KAAK,CAACC,IAAN,CAAWV,MAAX,CAAhB;;AACA,UAAIW,MAAM,CAACd,MAAD,EAAS,SAAT,CAAV,EAA+B;AAC7BW,qBAAa,CAACI,IAAd,CAAmBV,YAAnB;AACD;;AACDK,WAAK,KAAKA,KAAK,GAAGC,aAAa,CAACK,QAAd,CAAuBP,GAAvB,CAAb,CAAL;AACD;;AACD,QAAIF,SAAJ,EACEG,KAAK,KAAKA,KAAK,GAAGH,SAAS,CAACE,GAAD,CAAtB,CAAL;;AACF,QAAI,CAACC,KAAD,IAAUC,aAAa,CAACM,MAAd,GAAuB,CAArC,EAAwC;AACtC,UAAMC,eAAe,GAAG,mBAAI,IAAIC,GAAJ,CAAQR,aAAR,CAAJ,EAA4BS,GAA5B,CAAgC,UAACC,KAAD;AAAA,eAAWC,IAAI,CAACC,SAAL,CAAeF,KAAf,CAAX;AAAA,OAAhC,EAAkEG,IAAlE,CAAuE,IAAvE,CAAxB;;AACAC,UAAI,0CAAmCxB,GAAG,yBAAiBA,GAAjB,UAA0B,EAAhE,gCAAwFiB,eAAxF,0BAAuHI,IAAI,CAACC,SAAL,CAAed,GAAf,CAAvH,OAAJ;AACD;;AACD,WAAOC,KAAP;AACD,GAjBkB,GAiBf,KAAK,CAjBT;;AAkBA,MAAMgB,IAAI;AACRpB,QAAI,EAAEJ,QAAQ,CAACI,IAAD,CAAR,IAAkBqB,MAAM,CAACC,qBAAP,CAA6BtB,IAA7B,EAAmCU,QAAnC,CAA4CpB,UAA5C,CAAlB,GAA4EU,IAAI,CAACV,UAAD,CAAhF,GAA+FU,IAD7F;AAERF,YAAQ,EAAE,CAAC,CAACA,QAFJ;AAGRG,aAAS,EAAEC;AAHH,KAIPV,OAJO,EAIG,IAJH,CAAV;;AAMA,MAAIgB,MAAM,CAACd,MAAD,EAAS,SAAT,CAAV,EACE0B,IAAI,WAAJ,GAAerB,YAAf;AACF,SAAOqB,IAAP;AACD;;AACW,IAACG,UAAU,GAAG,SAAbA,UAAa,CAACC,KAAD;AAAA,SAAWC,SAAS,CAACJ,MAAM,CAACK,OAAP,CAAeF,KAAf,EAAsBV,GAAtB,CAA0B;AAAA;AAAA,QAAEnB,GAAF;AAAA,QAAOD,MAAP;;AAAA,WAAmB,CAC1FC,GAD0F,EAE1FF,SAAS,CAACC,MAAD,EAASC,GAAT,CAFiF,CAAnB;AAAA,GAA1B,CAAD,CAApB;AAAA,CAAd;;AAIA,IAACgC,cAAc,GAAG,SAAjBA,cAAiB,CAACxB,GAAD;AAAA,6BAAab,UAAb,EAA0Ba,GAA1B;AAAA,CAAlB","names":["wrapperKey","Symbol","propKey","buildProp","option","key","isObject","values","required","defaultValue","type","validator","_validator","val","valid","allowedValues","Array","from","hasOwn","push","includes","length","allowValuesText","Set","map","value","JSON","stringify","join","warn","prop","Object","getOwnPropertySymbols","buildProps","props","fromPairs","entries","definePropType"],"sources":["../../../../../packages/utils/vue/props.ts"],"sourcesContent":["import { warn } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { isObject } from '../types'\nimport { hasOwn } from '../objects'\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nconst wrapperKey = Symbol()\nexport type PropWrapper<T> = { [wrapperKey]: T }\n\nexport const propKey = '__elPropsReservedKey'\n\ntype ResolveProp<T> = ExtractPropTypes<{\n  key: { type: T; required: true }\n}>['key']\ntype ResolvePropType<T> = ResolveProp<T> extends { type: infer V }\n  ? V\n  : ResolveProp<T>\ntype ResolvePropTypeWithReadonly<T> = Readonly<T> extends Readonly<\n  Array<infer A>\n>\n  ? ResolvePropType<A[]>\n  : ResolvePropType<T>\n\ntype IfUnknown<T, V> = [unknown] extends [T] ? V : T\n\nexport type BuildPropOption<T, D extends BuildPropType<T, V, C>, R, V, C> = {\n  type?: T\n  values?: readonly V[]\n  required?: R\n  default?: R extends true\n    ? never\n    : D extends Record<string, unknown> | Array<any>\n    ? () => D\n    : (() => D) | D\n  validator?: ((val: any) => val is C) | ((val: any) => boolean)\n}\n\ntype _BuildPropType<T, V, C> =\n  | (T extends PropWrapper<unknown>\n      ? T[typeof wrapperKey]\n      : [V] extends [never]\n      ? ResolvePropTypeWithReadonly<T>\n      : never)\n  | V\n  | C\nexport type BuildPropType<T, V, C> = _BuildPropType<\n  IfUnknown<T, never>,\n  IfUnknown<V, never>,\n  IfUnknown<C, never>\n>\n\ntype _BuildPropDefault<T, D> = [T] extends [\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Record<string, unknown> | Array<any> | Function\n]\n  ? D\n  : D extends () => T\n  ? ReturnType<D>\n  : D\n\nexport type BuildPropDefault<T, D, R> = R extends true\n  ? { readonly default?: undefined }\n  : {\n      readonly default: Exclude<D, undefined> extends never\n        ? undefined\n        : Exclude<_BuildPropDefault<T, D>, undefined>\n    }\nexport type BuildPropReturn<T, D, R, V, C> = {\n  readonly type: PropType<BuildPropType<T, V, C>>\n  readonly required: IfUnknown<R, false>\n  readonly validator: ((val: unknown) => boolean) | undefined\n  [propKey]: true\n} & BuildPropDefault<\n  BuildPropType<T, V, C>,\n  IfUnknown<D, never>,\n  IfUnknown<R, false>\n>\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description 生成 prop，能更好地优化类型\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'large' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'large'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport function buildProp<\n  T = never,\n  D extends BuildPropType<T, V, C> = never,\n  R extends boolean = false,\n  V = never,\n  C = never\n>(\n  option: BuildPropOption<T, D, R, V, C>,\n  key?: string\n): BuildPropReturn<T, D, R, V, C> {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(option) || !!option[propKey]) return option as any\n\n  const { values, required, default: defaultValue, type, validator } = option\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = Array.from(values)\n            if (hasOwn(option, 'default')) {\n              allowedValues.push(defaultValue)\n            }\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  const prop: any = {\n    type:\n      isObject(type) && Object.getOwnPropertySymbols(type).includes(wrapperKey)\n        ? type[wrapperKey]\n        : type,\n    required: !!required,\n    validator: _validator,\n    [propKey]: true,\n  }\n  if (hasOwn(option, 'default')) prop.default = defaultValue\n\n  return prop as BuildPropReturn<T, D, R, V, C>\n}\n\ntype NativePropType = [\n  ((...args: any) => any) | { new (...args: any): any } | undefined | null\n]\n\nexport const buildProps = <\n  O extends {\n    [K in keyof O]: O[K] extends BuildPropReturn<any, any, any, any, any>\n      ? O[K]\n      : [O[K]] extends NativePropType\n      ? O[K]\n      : O[K] extends BuildPropOption<\n          infer T,\n          infer D,\n          infer R,\n          infer V,\n          infer C\n        >\n      ? D extends BuildPropType<T, V, C>\n        ? BuildPropOption<T, D, R, V, C>\n        : never\n      : never\n  }\n>(\n  props: O\n) =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as unknown as {\n    [K in keyof O]: O[K] extends { [propKey]: boolean }\n      ? O[K]\n      : [O[K]] extends NativePropType\n      ? O[K]\n      : O[K] extends BuildPropOption<\n          infer T,\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          infer _D,\n          infer R,\n          infer V,\n          infer C\n        >\n      ? BuildPropReturn<T, O[K]['default'], R, V, C>\n      : never\n  }\n\nexport const definePropType = <T>(val: any) =>\n  ({ [wrapperKey]: val } as PropWrapper<T>)\n"]},"metadata":{},"sourceType":"module"}