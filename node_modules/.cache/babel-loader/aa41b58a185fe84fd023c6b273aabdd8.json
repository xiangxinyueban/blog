{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { ref, getCurrentInstance, inject, computed, provide, unref } from 'vue';\nimport '../../tokens/index.mjs';\nimport '../../utils/index.mjs';\nimport { configProviderContextKey } from '../../tokens/config-provider.mjs';\nimport { debugWarn } from '../../utils/error.mjs';\nimport { keysOf } from '../../utils/objects.mjs';\nvar globalConfig = ref();\n\nfunction useGlobalConfig(key) {\n  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n  var config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;\n\n  if (key) {\n    return computed(function () {\n      var _a, _b;\n\n      return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;\n    });\n  } else {\n    return config;\n  }\n}\n\nvar provideGlobalConfig = function provideGlobalConfig(config, app) {\n  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _a;\n\n  var inSetup = !!getCurrentInstance();\n  var oldConfig = inSetup ? useGlobalConfig() : void 0;\n  var provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? provide : void 0;\n\n  if (!provideFn) {\n    debugWarn(\"provideGlobalConfig\", \"provideGlobalConfig() can only be used inside setup().\");\n    return;\n  }\n\n  var context = computed(function () {\n    var cfg = unref(config);\n    if (!(oldConfig == null ? void 0 : oldConfig.value)) return cfg;\n    return mergeConfig(oldConfig.value, cfg);\n  });\n  provideFn(configProviderContextKey, context);\n\n  if (global || !globalConfig.value) {\n    globalConfig.value = context.value;\n  }\n\n  return context;\n};\n\nvar mergeConfig = function mergeConfig(a, b) {\n  var _a;\n\n  var keys = _toConsumableArray( /* @__PURE__ */new Set([].concat(_toConsumableArray(keysOf(a)), _toConsumableArray(keysOf(b)))));\n\n  var obj = {};\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      obj[key] = (_a = b[key]) != null ? _a : a[key];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return obj;\n};\n\nexport { provideGlobalConfig, useGlobalConfig };","map":{"version":3,"mappings":";;;;;;;;;;;;;AAGA,IAAMA,YAAY,GAAGC,GAAG,EAAxB;;AACO,SAASC,eAAT,CAAyBC,GAAzB,EAAqD;AAAA,MAAvBC,YAAuB,uEAAR,KAAK,CAAG;AAC1D,MAAMC,MAAM,GAAGC,kBAAkB,KAAKC,MAAM,CAACC,wBAAD,EAA2BR,YAA3B,CAAX,GAAsDA,YAAvF;;AACA,MAAIG,GAAJ,EAAS;AACP,WAAOM,QAAQ,CAAC,YAAM;AACpB,UAAIC,EAAJ,EAAQC,EAAR;;AACA,aAAO,CAACA,EAAE,GAAG,CAACD,EAAE,GAAGL,MAAM,CAACO,KAAb,KAAuB,IAAvB,GAA8B,KAAK,CAAnC,GAAuCF,EAAE,CAACP,GAAD,CAA/C,KAAyD,IAAzD,GAAgEQ,EAAhE,GAAqEP,YAA5E;AACD,KAHc,CAAf;AAID,GALD,MAKO;AACL,WAAOC,MAAP;AACD;AACF;;AACW,IAACQ,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACR,MAAD,EAASS,GAAT,EAAiC;AAAA,MAAnBC,MAAmB,uEAAV,KAAU;;AAClE,MAAIL,EAAJ;;AACA,MAAMM,OAAO,GAAG,CAAC,CAACV,kBAAkB,EAApC;AACA,MAAMW,SAAS,GAAGD,OAAO,GAAGd,eAAe,EAAlB,GAAuB,KAAK,CAArD;AACA,MAAMgB,SAAS,GAAG,CAACR,EAAE,GAAGI,GAAG,IAAI,IAAP,GAAc,KAAK,CAAnB,GAAuBA,GAAG,CAACK,OAAjC,KAA6C,IAA7C,GAAoDT,EAApD,GAAyDM,OAAO,GAAGG,OAAH,GAAa,KAAK,CAApG;;AACA,MAAI,CAACD,SAAL,EAAgB;AACdE,aAAS,CAAC,qBAAD,EAAwB,wDAAxB,CAAT;AACA;AACD;;AACD,MAAMC,OAAO,GAAGZ,QAAQ,CAAC,YAAM;AAC7B,QAAMa,GAAG,GAAGC,KAAK,CAAClB,MAAD,CAAjB;AACA,QAAI,EAAEY,SAAS,IAAI,IAAb,GAAoB,KAAK,CAAzB,GAA6BA,SAAS,CAACL,KAAzC,CAAJ,EACE,OAAOU,GAAP;AACF,WAAOE,WAAW,CAACP,SAAS,CAACL,KAAX,EAAkBU,GAAlB,CAAlB;AACD,GALuB,CAAxB;AAMAJ,WAAS,CAACV,wBAAD,EAA2Ba,OAA3B,CAAT;;AACA,MAAIN,MAAM,IAAI,CAACf,YAAY,CAACY,KAA5B,EAAmC;AACjCZ,gBAAY,CAACY,KAAb,GAAqBS,OAAO,CAACT,KAA7B;AACD;;AACD,SAAOS,OAAP;AACF,CApBY;;AAqBZ,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACC,CAAD,EAAIC,CAAJ,EAAU;AAC5B,MAAIhB,EAAJ;;AACA,MAAMiB,IAAI,uBAAI,eAAmB,IAAIC,GAAJ,8BAAYC,MAAM,CAACJ,CAAD,CAAlB,sBAA0BI,MAAM,CAACH,CAAD,CAAhC,GAAvB,CAAV;;AACA,MAAMI,GAAG,GAAG,EAAZ;;AAH4B,6CAIVH,IAJU;AAAA;;AAAA;AAI5B,wDAAwB;AAAA,UAAbxB,GAAa;AACtB2B,SAAG,CAAC3B,GAAD,CAAH,GAAW,CAACO,EAAE,GAAGgB,CAAC,CAACvB,GAAD,CAAP,KAAiB,IAAjB,GAAwBO,EAAxB,GAA6Be,CAAC,CAACtB,GAAD,CAAzC;AACD;AAN2B;AAAA;AAAA;AAAA;AAAA;;AAO5B,SAAO2B,GAAP;AACD,CARD","names":["globalConfig","ref","useGlobalConfig","key","defaultValue","config","getCurrentInstance","inject","configProviderContextKey","computed","_a","_b","value","provideGlobalConfig","app","global","inSetup","oldConfig","provideFn","provide","debugWarn","context","cfg","unref","mergeConfig","a","b","keys","Set","keysOf","obj"],"sources":["../../../../../packages/hooks/use-global-config/index.ts"],"sourcesContent":["import { computed, getCurrentInstance, inject, provide, ref, unref } from 'vue'\nimport { configProviderContextKey } from '@element-plus/tokens'\nimport { debugWarn, keysOf } from '@element-plus/utils'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { App, Ref } from 'vue'\nimport type { ConfigProviderContext } from '@element-plus/tokens'\n\n// this is meant to fix global methods like `ElMessage(opts)`, this way we can inject current locale\n// into the component as default injection value.\n// refer to: https://github.com/element-plus/element-plus/issues/2610#issuecomment-887965266\nconst globalConfig = ref<ConfigProviderContext>()\n\nexport function useGlobalConfig<\n  K extends keyof ConfigProviderContext,\n  D extends ConfigProviderContext[K]\n>(\n  key: K,\n  defaultValue?: D\n): Ref<Exclude<ConfigProviderContext[K], undefined> | D>\nexport function useGlobalConfig(): Ref<ConfigProviderContext>\nexport function useGlobalConfig(\n  key?: keyof ConfigProviderContext,\n  defaultValue = undefined\n) {\n  const config = getCurrentInstance()\n    ? inject(configProviderContextKey, globalConfig)\n    : globalConfig\n  if (key) {\n    return computed(() => config.value?.[key] ?? defaultValue)\n  } else {\n    return config\n  }\n}\n\nexport const provideGlobalConfig = (\n  config: MaybeRef<ConfigProviderContext>,\n  app?: App,\n  global = false\n) => {\n  const inSetup = !!getCurrentInstance()\n  const oldConfig = inSetup ? useGlobalConfig() : undefined\n\n  const provideFn = app?.provide ?? (inSetup ? provide : undefined)\n  if (!provideFn) {\n    debugWarn(\n      'provideGlobalConfig',\n      'provideGlobalConfig() can only be used inside setup().'\n    )\n    return\n  }\n\n  const context = computed(() => {\n    const cfg = unref(config)\n    if (!oldConfig?.value) return cfg\n    return mergeConfig(oldConfig.value, cfg)\n  })\n  provideFn(configProviderContextKey, context)\n  if (global || !globalConfig.value) {\n    globalConfig.value = context.value\n  }\n  return context\n}\n\nconst mergeConfig = (\n  a: ConfigProviderContext,\n  b: ConfigProviderContext\n): ConfigProviderContext => {\n  const keys = [...new Set([...keysOf(a), ...keysOf(b)])]\n  const obj = {}\n  for (const key of keys) {\n    obj[key] = b[key] ?? a[key]\n  }\n  return obj\n}\n"]},"metadata":{},"sourceType":"module"}