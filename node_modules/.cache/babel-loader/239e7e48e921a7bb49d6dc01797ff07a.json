{"ast":null,"code":"import _objectSpread from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.parse-int.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport { isVNode, createVNode, render } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport NotificationConstructor from './notification2.mjs';\nimport { notificationTypes } from './notification.mjs';\nimport { useZIndex } from '../../../hooks/use-z-index/index.mjs';\nimport { isElement } from '../../../utils/types.mjs';\nimport { isString } from '@vue/shared';\nimport { debugWarn } from '../../../utils/error.mjs';\nvar notifications = {\n  \"top-left\": [],\n  \"top-right\": [],\n  \"bottom-left\": [],\n  \"bottom-right\": []\n};\nvar GAP_SIZE = 16;\nvar seed = 1;\n\nvar notify = function notify() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!isClient) return {\n    close: function close() {\n      return void 0;\n    }\n  };\n\n  if (typeof options === \"string\" || isVNode(options)) {\n    options = {\n      message: options\n    };\n  }\n\n  var position = options.position || \"top-right\";\n  var verticalOffset = options.offset || 0;\n  notifications[position].forEach(function (_ref) {\n    var vm2 = _ref.vm;\n\n    var _a;\n\n    verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;\n  });\n  verticalOffset += GAP_SIZE;\n\n  var _useZIndex = useZIndex(),\n      nextZIndex = _useZIndex.nextZIndex;\n\n  var id = \"notification_\".concat(seed++);\n  var userOnClose = options.onClose;\n\n  var props = _objectSpread(_objectSpread({\n    zIndex: nextZIndex(),\n    offset: verticalOffset\n  }, options), {}, {\n    id: id,\n    onClose: function onClose() {\n      close(id, position, userOnClose);\n    }\n  });\n\n  var appendTo = document.body;\n\n  if (isElement(options.appendTo)) {\n    appendTo = options.appendTo;\n  } else if (isString(options.appendTo)) {\n    appendTo = document.querySelector(options.appendTo);\n  }\n\n  if (!isElement(appendTo)) {\n    debugWarn(\"ElNotification\", \"the appendTo option is not an HTMLElement. Falling back to document.body.\");\n    appendTo = document.body;\n  }\n\n  var container = document.createElement(\"div\");\n  var vm = createVNode(NotificationConstructor, props, isVNode(props.message) ? {\n    \"default\": function _default() {\n      return props.message;\n    }\n  } : null);\n  vm.appContext = context != null ? context : notify._context;\n\n  vm.props.onDestroy = function () {\n    render(null, container);\n  };\n\n  render(vm, container);\n  notifications[position].push({\n    vm: vm\n  });\n  appendTo.appendChild(container.firstElementChild);\n  return {\n    close: function close() {\n      ;\n      vm.component.proxy.visible = false;\n    }\n  };\n};\n\nnotificationTypes.forEach(function (type) {\n  notify[type] = function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof options === \"string\" || isVNode(options)) {\n      options = {\n        message: options\n      };\n    }\n\n    return notify(_objectSpread(_objectSpread({}, options), {}, {\n      type: type\n    }));\n  };\n});\n\nfunction close(id, position, userOnClose) {\n  var orientedNotifications = notifications[position];\n  var idx = orientedNotifications.findIndex(function (_ref2) {\n    var vm2 = _ref2.vm;\n\n    var _a;\n\n    return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;\n  });\n  if (idx === -1) return;\n  var vm = orientedNotifications[idx].vm;\n  if (!vm) return;\n  userOnClose == null ? void 0 : userOnClose(vm);\n  var removedHeight = vm.el.offsetHeight;\n  var verticalPos = position.split(\"-\")[0];\n  orientedNotifications.splice(idx, 1);\n  var len = orientedNotifications.length;\n  if (len < 1) return;\n\n  for (var i = idx; i < len; i++) {\n    var _orientedNotification = orientedNotifications[i].vm,\n        el = _orientedNotification.el,\n        component = _orientedNotification.component;\n    var pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;\n    component.props.offset = pos;\n  }\n}\n\nfunction closeAll() {\n  for (var _i = 0, _Object$values = Object.values(notifications); _i < _Object$values.length; _i++) {\n    var orientedNotifications = _Object$values[_i];\n    orientedNotifications.forEach(function (_ref3) {\n      var vm = _ref3.vm;\n      ;\n      vm.component.proxy.visible = false;\n    });\n  }\n}\n\nnotify.closeAll = closeAll;\nnotify._context = null;\nexport { close, closeAll, notify as default };","map":{"version":3,"mappings":"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","names":["notifications","GAP_SIZE","seed","notify","options","context","isClient","close","isVNode","message","position","verticalOffset","offset","forEach","vm2","vm","_a","el","offsetHeight","useZIndex","nextZIndex","id","userOnClose","onClose","props","zIndex","appendTo","document","body","isElement","isString","querySelector","debugWarn","container","createElement","createVNode","NotificationConstructor","appContext","_context","onDestroy","render","push","appendChild","firstElementChild","component","proxy","visible","notificationTypes","type","orientedNotifications","idx","findIndex","removedHeight","verticalPos","split","splice","len","length","i","pos","Number","parseInt","style","closeAll","Object","values"],"sources":["../../../../../../packages/components/notification/src/notify.ts"],"sourcesContent":["import { createVNode, render } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { useZIndex } from '@element-plus/hooks'\nimport { debugWarn, isElement, isString, isVNode } from '@element-plus/utils'\nimport NotificationConstructor from './notification.vue'\nimport { notificationTypes } from './notification'\n\nimport type { AppContext, ComponentPublicInstance, VNode } from 'vue'\nimport type {\n  NotificationOptions,\n  NotificationProps,\n  NotificationQueue,\n  Notify,\n  NotifyFn,\n} from './notification'\n\n// This should be a queue but considering there were `non-autoclosable` notifications.\nconst notifications: Record<\n  NotificationOptions['position'],\n  NotificationQueue\n> = {\n  'top-left': [],\n  'top-right': [],\n  'bottom-left': [],\n  'bottom-right': [],\n}\n\n// the gap size between each notification\nconst GAP_SIZE = 16\nlet seed = 1\n\nconst notify: NotifyFn & Partial<Notify> & { _context: AppContext | null } =\n  function (options = {}, context: AppContext | null = null) {\n    if (!isClient) return { close: () => undefined }\n\n    if (typeof options === 'string' || isVNode(options)) {\n      options = { message: options }\n    }\n\n    const position = options.position || 'top-right'\n\n    let verticalOffset = options.offset || 0\n    notifications[position].forEach(({ vm }) => {\n      verticalOffset += (vm.el?.offsetHeight || 0) + GAP_SIZE\n    })\n    verticalOffset += GAP_SIZE\n\n    const { nextZIndex } = useZIndex()\n\n    const id = `notification_${seed++}`\n    const userOnClose = options.onClose\n    const props: Partial<NotificationProps> = {\n      // default options end\n      zIndex: nextZIndex(),\n      offset: verticalOffset,\n      ...options,\n      id,\n      onClose: () => {\n        close(id, position, userOnClose)\n      },\n    }\n\n    let appendTo: HTMLElement | null = document.body\n    if (isElement(options.appendTo)) {\n      appendTo = options.appendTo\n    } else if (isString(options.appendTo)) {\n      appendTo = document.querySelector(options.appendTo)\n    }\n\n    // should fallback to default value with a warning\n    if (!isElement(appendTo)) {\n      debugWarn(\n        'ElNotification',\n        'the appendTo option is not an HTMLElement. Falling back to document.body.'\n      )\n      appendTo = document.body\n    }\n\n    const container = document.createElement('div')\n\n    const vm = createVNode(\n      NotificationConstructor,\n      props,\n      isVNode(props.message)\n        ? {\n            default: () => props.message,\n          }\n        : null\n    )\n    vm.appContext = context ?? notify._context\n\n    // clean notification element preventing mem leak\n    vm.props!.onDestroy = () => {\n      render(null, container)\n    }\n\n    // instances will remove this item when close function gets called. So we do not need to worry about it.\n    render(vm, container)\n    notifications[position].push({ vm })\n    appendTo.appendChild(container.firstElementChild!)\n\n    return {\n      // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle\n      // for out component, so that all closing steps will not be skipped.\n      close: () => {\n        ;(\n          vm.component!.proxy as ComponentPublicInstance<{ visible: boolean }>\n        ).visible = false\n      },\n    }\n  }\nnotificationTypes.forEach((type) => {\n  notify[type] = (options = {}) => {\n    if (typeof options === 'string' || isVNode(options)) {\n      options = {\n        message: options,\n      }\n    }\n    return notify({\n      ...options,\n      type,\n    })\n  }\n})\n\n/**\n * This function gets called when user click `x` button or press `esc` or the time reached its limitation.\n * Emitted by transition@before-leave event so that we can fetch the current notification.offsetHeight, if this was called\n * by @after-leave the DOM element will be removed from the page thus we can no longer fetch the offsetHeight.\n * @param {String} id notification id to be closed\n * @param {Position} position the positioning strategy\n * @param {Function} userOnClose the callback called when close passed by user\n */\nexport function close(\n  id: string,\n  position: NotificationOptions['position'],\n  userOnClose?: (vm: VNode) => void\n): void {\n  // maybe we can store the index when inserting the vm to notification list.\n  const orientedNotifications = notifications[position]\n  const idx = orientedNotifications.findIndex(\n    ({ vm }) => vm.component?.props.id === id\n  )\n  if (idx === -1) return\n  const { vm } = orientedNotifications[idx]\n  if (!vm) return\n  // calling user's on close function before notification gets removed from DOM.\n  userOnClose?.(vm)\n\n  // note that this is called @before-leave, that's why we were able to fetch this property.\n  const removedHeight = vm.el!.offsetHeight\n  const verticalPos = position.split('-')[0]\n  orientedNotifications.splice(idx, 1)\n  const len = orientedNotifications.length\n  if (len < 1) return\n  // starting from the removing item.\n  for (let i = idx; i < len; i++) {\n    // new position equals the current offsetTop minus removed height plus 16px(the gap size between each item)\n    const { el, component } = orientedNotifications[i].vm\n    const pos =\n      Number.parseInt(el!.style[verticalPos], 10) - removedHeight - GAP_SIZE\n    component!.props.offset = pos\n  }\n}\n\nexport function closeAll(): void {\n  // loop through all directions, close them at once.\n  for (const orientedNotifications of Object.values(notifications)) {\n    orientedNotifications.forEach(({ vm }) => {\n      // same as the previous close method, we'd like to make sure lifecycle gets handle properly.\n      ;(\n        vm.component!.proxy as ComponentPublicInstance<{ visible: boolean }>\n      ).visible = false\n    })\n  }\n}\n\nnotify.closeAll = closeAll\nnotify._context = null\n\nexport default notify as Notify\n"]},"metadata":{},"sourceType":"module"}