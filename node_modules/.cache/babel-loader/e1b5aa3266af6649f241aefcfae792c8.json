{"ast":null,"code":"import _defineProperty from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-finite.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport { defineComponent, ref, reactive, computed, unref, watch, onMounted, onBeforeUnmount, h, withModifiers } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../../scrollbar/index.mjs';\nimport '../../../../utils/index.mjs';\nimport { HORIZONTAL, ScrollbarDirKey, SCROLLBAR_MIN_SIZE } from '../defaults.mjs';\nimport { virtualizedScrollbarProps } from '../props.mjs';\nimport { renderThumbStyle } from '../utils.mjs';\nimport { BAR_MAP } from '../../../scrollbar/src/util.mjs';\nimport { on, off } from '../../../../utils/dom/event.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nvar ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var GAP = 4;\n    var trackRef = ref();\n    var thumbRef = ref();\n    var frameHandle = null;\n    var onselectstartStore = null;\n    var state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    var bar = computed(function () {\n      return BAR_MAP[props.layout];\n    });\n    var trackSize = computed(function () {\n      return props.clientSize - GAP;\n    });\n    var trackStyle = computed(function () {\n      var _ref2;\n\n      return _ref2 = {\n        position: \"absolute\",\n        width: HORIZONTAL === props.layout ? \"\".concat(trackSize.value, \"px\") : \"6px\",\n        height: HORIZONTAL === props.layout ? \"6px\" : \"\".concat(trackSize.value, \"px\")\n      }, _defineProperty(_ref2, ScrollbarDirKey[props.layout], \"2px\"), _defineProperty(_ref2, \"right\", \"2px\"), _defineProperty(_ref2, \"bottom\", \"2px\"), _defineProperty(_ref2, \"borderRadius\", \"4px\"), _ref2;\n    });\n    var thumbSize = computed(function () {\n      var ratio = props.ratio;\n      var clientSize = props.clientSize;\n\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n\n      var SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    var thumbStyle = computed(function () {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n\n      var thumb = \"\".concat(thumbSize.value, \"px\");\n      var style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    var totalSteps = computed(function () {\n      return Math.floor(props.clientSize - thumbSize.value - GAP);\n    });\n\n    var attachEvents = function attachEvents() {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      var thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n\n      document.onselectstart = function () {\n        return false;\n      };\n\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    var detachEvents = function detachEvents() {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      var thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    var onThumbMouseDown = function onThumbMouseDown(e) {\n      e.stopImmediatePropagation();\n\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n\n    var onMouseUp = function onMouseUp() {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n\n    var onMouseMove = function onMouseMove(e) {\n      var isDragging = state.isDragging;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      var prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      var offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      var thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      var distance = offset - thumbClickPosition;\n      frameHandle = rAF(function () {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n\n    var clickTrackHandler = function clickTrackHandler(e) {\n      var offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      var thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      var distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n\n    var onScrollbarTouchStart = function onScrollbarTouchStart(e) {\n      return e.preventDefault();\n    };\n\n    watch(function () {\n      return props.scrollFrom;\n    }, function (v) {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onMounted(function () {\n      if (!isClient) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(function () {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return function () {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        \"class\": \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        \"class\": \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n});\nexport { ScrollBar as default };","map":{"version":3,"mappings":"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","names":["ScrollBar","defineComponent","name","props","virtualizedScrollbarProps","emits","setup","emit","GAP","trackRef","ref","thumbRef","frameHandle","onselectstartStore","state","reactive","isDragging","traveled","bar","computed","BAR_MAP","layout","trackSize","clientSize","trackStyle","position","width","HORIZONTAL","value","height","ScrollbarDirKey","thumbSize","ratio","Number","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","SCROLLBAR_MIN_SIZE","thumbStyle","isFinite","display","thumb","style","renderThumbStyle","size","move","totalSteps","attachEvents","on","window","onMouseMove","onMouseUp","thumbEl","unref","document","onselectstart","detachEvents","off","onThumbMouseDown","e","stopImmediatePropagation","ctrlKey","includes","button","axis","currentTarget","offset","client","getBoundingClientRect","direction","prevPage","cAF","thumbClickPosition","distance","rAF","clickTrackHandler","abs","target","thumbHalf","onScrollbarTouchStart","preventDefault","watch","scrollFrom","v","ceil","onMounted","isClient","onBeforeUnmount","h","role","onMousedown","withModifiers"],"sources":["../../../../../../../packages/components/virtual-list/src/components/scrollbar.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  h,\n  onBeforeUnmount,\n  onMounted,\n  reactive,\n  ref,\n  unref,\n  watch,\n  withModifiers,\n} from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { BAR_MAP } from '@element-plus/components/scrollbar'\nimport { cAF, off, on, rAF } from '@element-plus/utils'\n\nimport { HORIZONTAL, SCROLLBAR_MIN_SIZE, ScrollbarDirKey } from '../defaults'\nimport { virtualizedScrollbarProps } from '../props'\nimport { renderThumbStyle } from '../utils'\n\nimport type { CSSProperties } from 'vue'\n\nconst ScrollBar = defineComponent({\n  name: 'ElVirtualScrollBar',\n  props: virtualizedScrollbarProps,\n  emits: ['scroll', 'start-move', 'stop-move'],\n  setup(props, { emit }) {\n    const GAP = 4 // top 2 + bottom 2 | left 2 + right 2\n\n    // DOM refs\n    const trackRef = ref<HTMLElement>()\n    const thumbRef = ref<HTMLElement>()\n\n    // local variables\n    let frameHandle: null | number = null\n    let onselectstartStore: null | typeof document.onselectstart = null\n\n    // data\n    const state = reactive({\n      isDragging: false,\n      traveled: 0,\n    })\n\n    const bar = computed(() => BAR_MAP[props.layout])\n\n    const trackSize = computed(() => props.clientSize! - GAP)\n\n    const trackStyle = computed<CSSProperties>(() => ({\n      position: 'absolute',\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : '6px',\n      height: HORIZONTAL === props.layout ? '6px' : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: '2px',\n      right: '2px',\n      bottom: '2px',\n      borderRadius: '4px',\n    }))\n\n    const thumbSize = computed(() => {\n      const ratio = props.ratio!\n      const clientSize = props.clientSize!\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY\n      }\n\n      if (ratio >= 50) {\n        return (ratio * clientSize) / 100\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3\n      return Math.floor(\n        Math.min(\n          Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE),\n          SCROLLBAR_MAX_SIZE\n        )\n      )\n    })\n\n    // const sizeRange = computed(() => props.size - thumbSize.value)\n\n    const thumbStyle = computed<CSSProperties>(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: 'none',\n        }\n      }\n\n      const thumb = `${thumbSize.value}px`\n\n      const style: CSSProperties = renderThumbStyle(\n        {\n          bar: bar.value,\n          size: thumb,\n          move: state.traveled,\n        },\n        props.layout\n      )\n\n      return style\n    })\n\n    const totalSteps = computed(() =>\n      Math.floor(props.clientSize! - thumbSize.value - GAP)\n    )\n\n    const attachEvents = () => {\n      on(window, 'mousemove', onMouseMove)\n      on(window, 'mouseup', onMouseUp)\n\n      const thumbEl = unref(thumbRef)\n\n      if (!thumbEl) return\n\n      onselectstartStore = document.onselectstart\n      document.onselectstart = () => false\n\n      on(thumbEl, 'touchmove', onMouseMove)\n      on(thumbEl, 'touchend', onMouseUp)\n    }\n\n    const detachEvents = () => {\n      off(window, 'mousemove', onMouseMove)\n      off(window, 'mouseup', onMouseUp)\n\n      document.onselectstart = onselectstartStore\n      onselectstartStore = null\n\n      const thumbEl = unref(thumbRef)\n      if (!thumbEl) return\n\n      off(thumbEl, 'touchmove', onMouseMove)\n      off(thumbEl, 'touchend', onMouseUp)\n    }\n\n    const onThumbMouseDown = (e: Event) => {\n      e.stopImmediatePropagation()\n      if (\n        (e as KeyboardEvent).ctrlKey ||\n        [1, 2].includes((e as MouseEvent).button)\n      ) {\n        return\n      }\n\n      state.isDragging = true\n      state[bar.value.axis] =\n        e.currentTarget![bar.value.offset] -\n        (e[bar.value.client] -\n          (e.currentTarget as HTMLElement).getBoundingClientRect()[\n            bar.value.direction\n          ])\n\n      emit('start-move')\n      attachEvents()\n    }\n\n    const onMouseUp = () => {\n      state.isDragging = false\n      state[bar.value.axis] = 0\n      emit('stop-move')\n      detachEvents()\n    }\n\n    const onMouseMove = (e: Event) => {\n      const { isDragging } = state\n      if (!isDragging) return\n      if (!thumbRef.value || !trackRef.value) return\n\n      const prevPage = state[bar.value.axis]\n      if (!prevPage) return\n\n      cAF(frameHandle!)\n      // using the current track's offset top/left - the current pointer's clientY/clientX\n      // to get the relative position of the pointer to the track.\n      const offset =\n        (trackRef.value.getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]) *\n        -1\n\n      // find where the thumb was clicked on.\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage\n      /**\n       *  +--------------+                                   +--------------+\n       *  |              -  <--------- thumb.offsetTop       |              |\n       *  |             |+|             <--+                 |              |\n       *  |              -                 |                 |              |\n       *  |   Content    |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              -\n       *  |              |                 +-->              |             |+|\n       *  |              |                                   |              -\n       *  +--------------+                                   +--------------+\n       */\n\n      // using the current position - prev position to\n\n      const distance = offset - thumbClickPosition\n      // get how many steps in total.\n      // gap of 2 on top, 2 on bottom, in total 4.\n      // using totalSteps ÷ totalSize getting each step's size * distance to get the new\n      // scroll offset to scrollTo\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(\n          0,\n          Math.min(\n            distance,\n            totalSteps.value // 2 is the top value\n          )\n        )\n        emit('scroll', distance, totalSteps.value)\n      })\n    }\n\n    const clickTrackHandler = (e: MouseEvent) => {\n      const offset = Math.abs(\n        (e.target as HTMLElement).getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]\n      )\n      const thumbHalf = thumbRef.value![bar.value.offset] / 2\n      const distance = offset - thumbHalf\n\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value))\n      emit('scroll', distance, totalSteps.value)\n    }\n\n    const onScrollbarTouchStart = (e: Event) => e.preventDefault()\n\n    watch(\n      () => props.scrollFrom,\n      (v) => {\n        if (state.isDragging) return\n        /**\n         *  this is simply mapping the current scrollbar offset\n         *\n         *  formula 1:\n         *    v = scrollOffset / (estimatedTotalSize - clientSize)\n         *    traveled = v * (clientSize - thumbSize - GAP) --> v * totalSteps\n         *\n         *  formula 2:\n         *    traveled = (v * clientSize) / (clientSize / totalSteps) --> (v * clientSize) * (totalSteps / clientSize) --> v * totalSteps\n         */\n        state.traveled = Math.ceil(v! * totalSteps.value)\n      }\n    )\n\n    onMounted(() => {\n      if (!isClient) return\n\n      on(trackRef.value!, 'touchstart', onScrollbarTouchStart)\n      on(thumbRef.value!, 'touchstart', onThumbMouseDown)\n    })\n\n    onBeforeUnmount(() => {\n      off(trackRef.value!, 'touchstart', onScrollbarTouchStart)\n      detachEvents()\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          role: 'presentation',\n          ref: trackRef,\n          class: 'el-virtual-scrollbar',\n          style: trackStyle.value,\n          onMousedown: withModifiers(clickTrackHandler, ['stop', 'prevent']),\n        },\n        h(\n          'div',\n          {\n            ref: thumbRef,\n            class: 'el-scrollbar__thumb',\n            style: thumbStyle.value,\n            onMousedown: onThumbMouseDown,\n          },\n          []\n        )\n      )\n    }\n  },\n})\n\nexport default ScrollBar\n"]},"metadata":{},"sourceType":"module"}