{"ast":null,"code":"import _classCallCheck from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport { isEqual } from 'lodash-unified';\nimport Node from './node.mjs';\n\nvar flatNodes = function flatNodes(nodes, leafOnly) {\n  return nodes.reduce(function (res, node) {\n    if (node.isLeaf) {\n      res.push(node);\n    } else {\n      !leafOnly && res.push(node);\n      res = res.concat(flatNodes(node.children, leafOnly));\n    }\n\n    return res;\n  }, []);\n};\n\nvar Store = /*#__PURE__*/function () {\n  function Store(data, config) {\n    var _this = this;\n\n    _classCallCheck(this, Store);\n\n    this.config = config;\n    var nodes = (data || []).map(function (nodeData) {\n      return new Node(nodeData, _this.config);\n    });\n    this.nodes = nodes;\n    this.allNodes = flatNodes(nodes, false);\n    this.leafNodes = flatNodes(nodes, true);\n  }\n\n  _createClass(Store, [{\n    key: \"getNodes\",\n    value: function getNodes() {\n      return this.nodes;\n    }\n  }, {\n    key: \"getFlattedNodes\",\n    value: function getFlattedNodes(leafOnly) {\n      return leafOnly ? this.leafNodes : this.allNodes;\n    }\n  }, {\n    key: \"appendNode\",\n    value: function appendNode(nodeData, parentNode) {\n      var node = parentNode ? parentNode.appendChild(nodeData) : new Node(nodeData, this.config);\n      if (!parentNode) this.nodes.push(node);\n      this.allNodes.push(node);\n      node.isLeaf && this.leafNodes.push(node);\n    }\n  }, {\n    key: \"appendNodes\",\n    value: function appendNodes(nodeDataList, parentNode) {\n      var _this2 = this;\n\n      nodeDataList.forEach(function (nodeData) {\n        return _this2.appendNode(nodeData, parentNode);\n      });\n    }\n  }, {\n    key: \"getNodeByValue\",\n    value: function getNodeByValue(value) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!value && value !== 0) return null;\n      var node = this.getFlattedNodes(leafOnly).find(function (node2) {\n        return isEqual(node2.value, value) || isEqual(node2.pathValues, value);\n      });\n      return node || null;\n    }\n  }, {\n    key: \"getSameNode\",\n    value: function getSameNode(node) {\n      if (!node) return null;\n      var node_ = this.getFlattedNodes(false).find(function (_ref) {\n        var value = _ref.value,\n            level = _ref.level;\n        return isEqual(node.value, value) && node.level === level;\n      });\n      return node_ || null;\n    }\n  }]);\n\n  return Store;\n}();\n\nexport { Store as default };","map":{"version":3,"mappings":";;;;;;;;;;;;AAEA,IAAMA,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAQC,QAAR,EAAqB;AACrC,SAAOD,KAAK,CAACE,MAAN,CAAa,UAACC,GAAD,EAAMC,IAAN,EAAe;AACjC,QAAIA,IAAI,CAACC,MAAT,EAAiB;AACfF,SAAG,CAACG,IAAJ,CAASF,IAAT;AACD,KAFD,MAEO;AACL,OAACH,QAAD,IAAaE,GAAG,CAACG,IAAJ,CAASF,IAAT,CAAb;AACAD,SAAG,GAAGA,GAAG,CAACI,MAAJ,CAAWR,SAAS,CAACK,IAAI,CAACI,QAAN,EAAgBP,QAAhB,CAApB,CAAN;AACD;;AACD,WAAOE,GAAP;AACD,GARM,EAQJ,EARI,CAAP;AASD,CAVD;;IAWqBM,K;AACnB,iBAAYC,IAAZ,EAAkBC,MAAlB,EAA0B;AAAA;;AAAA;;AACxB,SAAKA,MAAL,GAAcA,MAAd;AACA,QAAMX,KAAK,GAAG,CAACU,IAAI,IAAI,EAAT,EAAaE,GAAb,CAAiB,UAACC,QAAD;AAAA,aAAc,IAAIC,IAAJ,CAASD,QAAT,EAAmB,KAAI,CAACF,MAAxB,CAAd;AAAA,KAAjB,CAAd;AACA,SAAKX,KAAL,GAAaA,KAAb;AACA,SAAKe,QAAL,GAAgBhB,SAAS,CAACC,KAAD,EAAQ,KAAR,CAAzB;AACA,SAAKgB,SAAL,GAAiBjB,SAAS,CAACC,KAAD,EAAQ,IAAR,CAA1B;AACD;;;;WACD,oBAAW;AACT,aAAO,KAAKA,KAAZ;AACD;;;WACD,yBAAgBC,QAAhB,EAA0B;AACxB,aAAOA,QAAQ,GAAG,KAAKe,SAAR,GAAoB,KAAKD,QAAxC;AACD;;;WACD,oBAAWF,QAAX,EAAqBI,UAArB,EAAiC;AAC/B,UAAMb,IAAI,GAAGa,UAAU,GAAGA,UAAU,CAACC,WAAX,CAAuBL,QAAvB,CAAH,GAAsC,IAAIC,IAAJ,CAASD,QAAT,EAAmB,KAAKF,MAAxB,CAA7D;AACA,UAAI,CAACM,UAAL,EACE,KAAKjB,KAAL,CAAWM,IAAX,CAAgBF,IAAhB;AACF,WAAKW,QAAL,CAAcT,IAAd,CAAmBF,IAAnB;AACAA,UAAI,CAACC,MAAL,IAAe,KAAKW,SAAL,CAAeV,IAAf,CAAoBF,IAApB,CAAf;AACD;;;WACD,qBAAYe,YAAZ,EAA0BF,UAA1B,EAAsC;AAAA;;AACpCE,kBAAY,CAACC,OAAb,CAAqB,UAACP,QAAD;AAAA,eAAc,MAAI,CAACQ,UAAL,CAAgBR,QAAhB,EAA0BI,UAA1B,CAAd;AAAA,OAArB;AACD;;;WACD,wBAAeK,KAAf,EAAwC;AAAA,UAAlBrB,QAAkB,uEAAP,KAAO;AACtC,UAAI,CAACqB,KAAD,IAAUA,KAAK,KAAK,CAAxB,EACE,OAAO,IAAP;AACF,UAAMlB,IAAI,GAAG,KAAKmB,eAAL,CAAqBtB,QAArB,EAA+BuB,IAA/B,CAAoC,UAACC,KAAD;AAAA,eAAWC,OAAO,CAACD,KAAK,CAACH,KAAP,EAAcA,KAAd,CAAP,IAA+BI,OAAO,CAACD,KAAK,CAACE,UAAP,EAAmBL,KAAnB,CAAjD;AAAA,OAApC,CAAb;AACA,aAAOlB,IAAI,IAAI,IAAf;AACD;;;WACD,qBAAYA,IAAZ,EAAkB;AAChB,UAAI,CAACA,IAAL,EACE,OAAO,IAAP;AACF,UAAMwB,KAAK,GAAG,KAAKL,eAAL,CAAqB,KAArB,EAA4BC,IAA5B,CAAiC;AAAA,YAAGF,KAAH,QAAGA,KAAH;AAAA,YAAUO,KAAV,QAAUA,KAAV;AAAA,eAAsBH,OAAO,CAACtB,IAAI,CAACkB,KAAN,EAAaA,KAAb,CAAP,IAA8BlB,IAAI,CAACyB,KAAL,KAAeA,KAAnE;AAAA,OAAjC,CAAd;AACA,aAAOD,KAAK,IAAI,IAAhB;AACD","names":["flatNodes","nodes","leafOnly","reduce","res","node","isLeaf","push","concat","children","Store","data","config","map","nodeData","Node","allNodes","leafNodes","parentNode","appendChild","nodeDataList","forEach","appendNode","value","getFlattedNodes","find","node2","isEqual","pathValues","node_","level"],"sources":["../../../../../../packages/components/cascader-panel/src/store.ts"],"sourcesContent":["import { isEqual } from 'lodash-unified'\nimport Node from './node'\n\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  CascaderConfig,\n  CascaderNodePathValue,\n  CascaderNodeValue,\n  CascaderOption,\n} from './node'\n\nconst flatNodes = (nodes: Node[], leafOnly: boolean) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node)\n    } else {\n      !leafOnly && res.push(node)\n      res = res.concat(flatNodes(node.children, leafOnly))\n    }\n    return res\n  }, [] as Node[])\n}\n\nexport default class Store {\n  readonly nodes: Node[]\n  readonly allNodes: Node[]\n  readonly leafNodes: Node[]\n\n  constructor(data: CascaderOption[], readonly config: CascaderConfig) {\n    const nodes = (data || []).map(\n      (nodeData) => new Node(nodeData, this.config)\n    )\n    this.nodes = nodes\n    this.allNodes = flatNodes(nodes, false)\n    this.leafNodes = flatNodes(nodes, true)\n  }\n\n  getNodes() {\n    return this.nodes\n  }\n\n  getFlattedNodes(leafOnly: boolean) {\n    return leafOnly ? this.leafNodes : this.allNodes\n  }\n\n  appendNode(nodeData: CascaderOption, parentNode?: Node) {\n    const node = parentNode\n      ? parentNode.appendChild(nodeData)\n      : new Node(nodeData, this.config)\n\n    if (!parentNode) this.nodes.push(node)\n\n    this.allNodes.push(node)\n    node.isLeaf && this.leafNodes.push(node)\n  }\n\n  appendNodes(nodeDataList: CascaderOption[], parentNode: Node) {\n    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode))\n  }\n\n  // when checkStrictly, leaf node first\n  getNodeByValue(\n    value: CascaderNodeValue | CascaderNodePathValue,\n    leafOnly = false\n  ): Nullable<Node> {\n    if (!value && value !== 0) return null\n\n    const node = this.getFlattedNodes(leafOnly).find(\n      (node) => isEqual(node.value, value) || isEqual(node.pathValues, value)\n    )\n\n    return node || null\n  }\n\n  getSameNode(node: Node): Nullable<Node> {\n    if (!node) return null\n\n    const node_ = this.getFlattedNodes(false).find(\n      ({ value, level }) => isEqual(node.value, value) && node.level === level\n    )\n\n    return node_ || null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}