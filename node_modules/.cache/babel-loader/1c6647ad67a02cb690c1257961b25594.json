{"ast":null,"code":"import _defineProperty from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _asyncToGenerator from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { defineComponent, getCurrentInstance, useAttrs, useSlots, shallowRef, ref, computed, nextTick, watch, onMounted, onUpdated, toRef, withDirectives, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createCommentVNode, Fragment, renderSlot, createElementVNode, mergeProps, createBlock, withCtx, resolveDynamicComponent, withModifiers, createVNode, toDisplayString, vShow } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport { isNil } from 'lodash-unified';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { View, Hide, CircleClose } from '@element-plus/icons-vue';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../constants/index.mjs';\nimport { calcTextareaHeight } from './utils.mjs';\nimport { inputProps, inputEmits } from './input.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useAttrs as useAttrs$1 } from '../../../hooks/use-attrs/index.mjs';\nimport { useFormItem } from '../../../hooks/use-form-item/index.mjs';\nimport { useSize, useDisabled } from '../../../hooks/use-common-props/index.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { ValidateComponentsMap } from '../../../utils/vue/icon.mjs';\nimport { isObject } from '@vue/shared';\nimport { UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';\nimport { isKorean } from '../../../utils/i18n.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nvar _hoisted_1 = [\"type\", \"disabled\", \"readonly\", \"autocomplete\", \"tabindex\", \"aria-label\", \"placeholder\"];\nvar _hoisted_2 = [\"tabindex\", \"disabled\", \"readonly\", \"autocomplete\", \"aria-label\", \"placeholder\"];\nvar __default__ = {\n  name: \"ElInput\",\n  inheritAttrs: false\n};\n\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: inputProps,\n  emits: inputEmits,\n  setup: function setup(__props, _ref2) {\n    var expose = _ref2.expose,\n        emit = _ref2.emit;\n    var props = __props;\n    var PENDANT_MAP = {\n      suffix: \"append\",\n      prefix: \"prepend\"\n    };\n    var instance = getCurrentInstance();\n    var rawAttrs = useAttrs();\n    var slots = useSlots();\n    var attrs = useAttrs$1();\n\n    var _useFormItem = useFormItem(),\n        form = _useFormItem.form,\n        formItem = _useFormItem.formItem;\n\n    var inputSize = useSize();\n    var inputDisabled = useDisabled();\n    var nsInput = useNamespace(\"input\");\n    var nsTextarea = useNamespace(\"textarea\");\n    var input = shallowRef();\n    var textarea = shallowRef();\n    var focused = ref(false);\n    var hovering = ref(false);\n    var isComposing = ref(false);\n    var passwordVisible = ref(false);\n    var textareaCalcStyle = shallowRef(props.inputStyle);\n\n    var _ref = computed(function () {\n      return input.value || textarea.value;\n    });\n\n    var needStatusIcon = computed(function () {\n      var _a;\n\n      return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;\n    });\n    var validateState = computed(function () {\n      return (formItem == null ? void 0 : formItem.validateState) || \"\";\n    });\n    var validateIcon = computed(function () {\n      return ValidateComponentsMap[validateState.value];\n    });\n    var passwordIcon = computed(function () {\n      return passwordVisible.value ? View : Hide;\n    });\n    var containerStyle = computed(function () {\n      return [rawAttrs.style, props.inputStyle];\n    });\n    var textareaStyle = computed(function () {\n      return [props.inputStyle, textareaCalcStyle.value, {\n        resize: props.resize\n      }];\n    });\n    var nativeInputValue = computed(function () {\n      return isNil(props.modelValue) ? \"\" : String(props.modelValue);\n    });\n    var showClear = computed(function () {\n      return props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value);\n    });\n    var showPwdVisible = computed(function () {\n      return props.showPassword && !inputDisabled.value && !props.readonly && (!!nativeInputValue.value || focused.value);\n    });\n    var isWordLimitVisible = computed(function () {\n      return props.showWordLimit && !!attrs.value.maxlength && (props.type === \"text\" || props.type === \"textarea\") && !inputDisabled.value && !props.readonly && !props.showPassword;\n    });\n    var textLength = computed(function () {\n      return Array.from(nativeInputValue.value).length;\n    });\n    var inputExceed = computed(function () {\n      return !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength);\n    });\n    var suffixVisible = computed(function () {\n      return !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value;\n    });\n\n    var resizeTextarea = function resizeTextarea() {\n      var type = props.type,\n          autosize = props.autosize;\n      if (!isClient || type !== \"textarea\") return;\n\n      if (autosize) {\n        var minRows = isObject(autosize) ? autosize.minRows : void 0;\n        var maxRows = isObject(autosize) ? autosize.maxRows : void 0;\n        textareaCalcStyle.value = _objectSpread({}, calcTextareaHeight(textarea.value, minRows, maxRows));\n      } else {\n        textareaCalcStyle.value = {\n          minHeight: calcTextareaHeight(textarea.value).minHeight\n        };\n      }\n    };\n\n    var setNativeInputValue = function setNativeInputValue() {\n      var input2 = _ref.value;\n      if (!input2 || input2.value === nativeInputValue.value) return;\n      input2.value = nativeInputValue.value;\n    };\n\n    var calcIconOffset = function calcIconOffset(place) {\n      var el = instance.vnode.el;\n      if (!el) return;\n      var elList = Array.from(el.querySelectorAll(\".\".concat(nsInput.e(place))));\n      var target = elList.find(function (item) {\n        return item.parentNode === el;\n      });\n      if (!target) return;\n      var pendant = PENDANT_MAP[place];\n\n      if (slots[pendant]) {\n        target.style.transform = \"translateX(\".concat(place === \"suffix\" ? \"-\" : \"\").concat(el.querySelector(\".\".concat(nsInput.be(\"group\", pendant))).offsetWidth, \"px)\");\n      } else {\n        target.removeAttribute(\"style\");\n      }\n    };\n\n    var updateIconOffset = function updateIconOffset() {\n      calcIconOffset(\"prefix\");\n      calcIconOffset(\"suffix\");\n    };\n\n    var handleInput = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(event) {\n        var value;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                value = event.target.value;\n\n                if (!isComposing.value) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                if (!(value === nativeInputValue.value)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 5:\n                emit(UPDATE_MODEL_EVENT, value);\n                emit(\"input\", value);\n                _context.next = 9;\n                return nextTick();\n\n              case 9:\n                setNativeInputValue();\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function handleInput(_x) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    var handleChange = function handleChange(event) {\n      emit(\"change\", event.target.value);\n    };\n\n    var handleCompositionStart = function handleCompositionStart(event) {\n      emit(\"compositionstart\", event);\n      isComposing.value = true;\n    };\n\n    var handleCompositionUpdate = function handleCompositionUpdate(event) {\n      var _a;\n\n      emit(\"compositionupdate\", event);\n      var text = (_a = event.target) == null ? void 0 : _a.value;\n      var lastCharacter = text[text.length - 1] || \"\";\n      isComposing.value = !isKorean(lastCharacter);\n    };\n\n    var handleCompositionEnd = function handleCompositionEnd(event) {\n      emit(\"compositionend\", event);\n\n      if (isComposing.value) {\n        isComposing.value = false;\n        handleInput(event);\n      }\n    };\n\n    var handlePasswordVisible = function handlePasswordVisible() {\n      passwordVisible.value = !passwordVisible.value;\n      focus();\n    };\n\n    var focus = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var _a;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return nextTick();\n\n              case 2:\n                (_a = _ref.value) == null ? void 0 : _a.focus();\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function focus() {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    var blur = function blur() {\n      var _a;\n\n      return (_a = _ref.value) == null ? void 0 : _a.blur();\n    };\n\n    var handleFocus = function handleFocus(event) {\n      focused.value = true;\n      emit(\"focus\", event);\n    };\n\n    var handleBlur = function handleBlur(event) {\n      var _a;\n\n      focused.value = false;\n      emit(\"blur\", event);\n\n      if (props.validateEvent) {\n        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, \"blur\")[\"catch\"](function (err) {\n          return debugWarn(err);\n        });\n      }\n    };\n\n    var handleMouseLeave = function handleMouseLeave(evt) {\n      hovering.value = false;\n      emit(\"mouseleave\", evt);\n    };\n\n    var handleMouseEnter = function handleMouseEnter(evt) {\n      hovering.value = true;\n      emit(\"mouseenter\", evt);\n    };\n\n    var handleKeydown = function handleKeydown(evt) {\n      emit(\"keydown\", evt);\n    };\n\n    var select = function select() {\n      var _a;\n\n      (_a = _ref.value) == null ? void 0 : _a.select();\n    };\n\n    var clear = function clear() {\n      emit(UPDATE_MODEL_EVENT, \"\");\n      emit(\"change\", \"\");\n      emit(\"clear\");\n      emit(\"input\", \"\");\n    };\n\n    watch(function () {\n      return props.modelValue;\n    }, function () {\n      var _a;\n\n      nextTick(function () {\n        return resizeTextarea();\n      });\n\n      if (props.validateEvent) {\n        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, \"change\")[\"catch\"](function (err) {\n          return debugWarn(err);\n        });\n      }\n    });\n    watch(nativeInputValue, function () {\n      return setNativeInputValue();\n    });\n    watch(function () {\n      return props.type;\n    }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return nextTick();\n\n            case 2:\n              setNativeInputValue();\n              resizeTextarea();\n              updateIconOffset();\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    })));\n    var innerSuffixRef = ref();\n    var innerPrefixRef = ref();\n    var inputStyleInner = ref({});\n\n    var getSuffixOrPrefixWidth = function getSuffixOrPrefixWidth(slotElm, defaultVal) {\n      if (slotElm.value) {\n        var slotElmWidth = slotElm.value.offsetWidth;\n        return slotElmWidth > 0 ? slotElmWidth + 16 : defaultVal;\n      }\n\n      return defaultVal;\n    };\n\n    var setInputPadding = function setInputPadding() {\n      inputStyleInner.value = _objectSpread({\n        paddingRight: \"\".concat(getSuffixOrPrefixWidth(innerSuffixRef, 0), \"px\"),\n        paddingLeft: \"\".concat(getSuffixOrPrefixWidth(innerPrefixRef, 11), \"px\")\n      }, props.inputStyle);\n    };\n\n    watch(showClear, function () {\n      nextTick(function () {\n        setInputPadding();\n      });\n    });\n    onMounted( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              setInputPadding();\n              setNativeInputValue();\n              updateIconOffset();\n              _context4.next = 5;\n              return nextTick();\n\n            case 5:\n              resizeTextarea();\n\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    })));\n    onUpdated( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n      return regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return nextTick();\n\n            case 2:\n              updateIconOffset();\n\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    })));\n    expose({\n      input: input,\n      textarea: textarea,\n      ref: _ref,\n      textareaStyle: textareaStyle,\n      autosize: toRef(props, \"autosize\"),\n      focus: focus,\n      blur: blur,\n      select: select,\n      clear: clear,\n      resizeTextarea: resizeTextarea\n    });\n    return function (_ctx, _cache) {\n      var _ref8;\n\n      return withDirectives((openBlock(), createElementBlock(\"div\", {\n        \"class\": normalizeClass([_ctx.type === \"textarea\" ? unref(nsTextarea).b() : unref(nsInput).b(), unref(nsInput).m(unref(inputSize)), unref(nsInput).is(\"disabled\", unref(inputDisabled)), unref(nsInput).is(\"exceed\", unref(inputExceed)), (_ref8 = {}, _defineProperty(_ref8, unref(nsInput).b(\"group\"), _ctx.$slots.prepend || _ctx.$slots.append), _defineProperty(_ref8, unref(nsInput).bm(\"group\", \"append\"), _ctx.$slots.append), _defineProperty(_ref8, unref(nsInput).bm(\"group\", \"prepend\"), _ctx.$slots.prepend), _defineProperty(_ref8, unref(nsInput).m(\"prefix\"), _ctx.$slots.prefix || _ctx.prefixIcon), _defineProperty(_ref8, unref(nsInput).m(\"suffix\"), _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword), _defineProperty(_ref8, unref(nsInput).m(\"suffix--password-clear\"), unref(showClear) && unref(showPwdVisible)), _ref8), _ctx.$attrs[\"class\"]]),\n        style: normalizeStyle(unref(containerStyle)),\n        onMouseenter: handleMouseEnter,\n        onMouseleave: handleMouseLeave\n      }, [createCommentVNode(\" input \"), _ctx.type !== \"textarea\" ? (openBlock(), createElementBlock(Fragment, {\n        key: 0\n      }, [createCommentVNode(\" prepend slot \"), _ctx.$slots.prepend ? (openBlock(), createElementBlock(\"div\", {\n        key: 0,\n        \"class\": normalizeClass(unref(nsInput).be(\"group\", \"prepend\"))\n      }, [renderSlot(_ctx.$slots, \"prepend\")], 2)) : createCommentVNode(\"v-if\", true), createElementVNode(\"input\", mergeProps({\n        ref_key: \"input\",\n        ref: input,\n        \"class\": unref(nsInput).e(\"inner\")\n      }, unref(attrs), {\n        type: _ctx.showPassword ? passwordVisible.value ? \"text\" : \"password\" : _ctx.type,\n        disabled: unref(inputDisabled),\n        readonly: _ctx.readonly,\n        autocomplete: _ctx.autocomplete,\n        tabindex: _ctx.tabindex,\n        \"aria-label\": _ctx.label,\n        placeholder: _ctx.placeholder,\n        style: inputStyleInner.value,\n        onCompositionstart: handleCompositionStart,\n        onCompositionupdate: handleCompositionUpdate,\n        onCompositionend: handleCompositionEnd,\n        onInput: handleInput,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onKeydown: handleKeydown\n      }), null, 16, _hoisted_1), createCommentVNode(\" prefix slot \"), _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock(\"span\", {\n        key: 1,\n        \"class\": normalizeClass(unref(nsInput).e(\"prefix\"))\n      }, [createElementVNode(\"span\", {\n        ref_key: \"innerPrefixRef\",\n        ref: innerPrefixRef,\n        \"class\": normalizeClass(unref(nsInput).e(\"prefix-inner\"))\n      }, [renderSlot(_ctx.$slots, \"prefix\"), _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {\n        key: 0,\n        \"class\": normalizeClass(unref(nsInput).e(\"icon\"))\n      }, {\n        \"default\": withCtx(function () {\n          return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))];\n        }),\n        _: 1\n      }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true)], 2)], 2)) : createCommentVNode(\"v-if\", true), createCommentVNode(\" suffix slot \"), unref(suffixVisible) ? (openBlock(), createElementBlock(\"span\", {\n        key: 2,\n        \"class\": normalizeClass(unref(nsInput).e(\"suffix\"))\n      }, [createElementVNode(\"span\", {\n        ref_key: \"innerSuffixRef\",\n        ref: innerSuffixRef,\n        \"class\": normalizeClass(unref(nsInput).e(\"suffix-inner\"))\n      }, [!unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, {\n        key: 0\n      }, [renderSlot(_ctx.$slots, \"suffix\"), _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {\n        key: 0,\n        \"class\": normalizeClass(unref(nsInput).e(\"icon\"))\n      }, {\n        \"default\": withCtx(function () {\n          return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))];\n        }),\n        _: 1\n      }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true)], 64)) : createCommentVNode(\"v-if\", true), unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {\n        key: 1,\n        \"class\": normalizeClass([unref(nsInput).e(\"icon\"), unref(nsInput).e(\"clear\")]),\n        onMousedown: _cache[0] || (_cache[0] = withModifiers(function () {}, [\"prevent\"])),\n        onClick: clear\n      }, {\n        \"default\": withCtx(function () {\n          return [createVNode(unref(CircleClose))];\n        }),\n        _: 1\n      }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true), unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {\n        key: 2,\n        \"class\": normalizeClass([unref(nsInput).e(\"icon\"), unref(nsInput).e(\"clear\")]),\n        onClick: handlePasswordVisible\n      }, {\n        \"default\": withCtx(function () {\n          return [(openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))];\n        }),\n        _: 1\n      }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true), unref(isWordLimitVisible) ? (openBlock(), createElementBlock(\"span\", {\n        key: 3,\n        \"class\": normalizeClass(unref(nsInput).e(\"count\"))\n      }, [createElementVNode(\"span\", {\n        \"class\": normalizeClass(unref(nsInput).e(\"count-inner\"))\n      }, toDisplayString(unref(textLength)) + \" / \" + toDisplayString(unref(attrs).maxlength), 3)], 2)) : createCommentVNode(\"v-if\", true)], 2), unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {\n        key: 0,\n        \"class\": normalizeClass([unref(nsInput).e(\"icon\"), unref(nsInput).e(\"validateIcon\"), unref(nsInput).is(\"loading\", unref(validateState) === \"validating\")])\n      }, {\n        \"default\": withCtx(function () {\n          return [(openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))];\n        }),\n        _: 1\n      }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true)], 2)) : createCommentVNode(\"v-if\", true), createCommentVNode(\" append slot \"), _ctx.$slots.append ? (openBlock(), createElementBlock(\"div\", {\n        key: 3,\n        \"class\": normalizeClass(unref(nsInput).be(\"group\", \"append\"))\n      }, [renderSlot(_ctx.$slots, \"append\")], 2)) : createCommentVNode(\"v-if\", true)], 64)) : (openBlock(), createElementBlock(Fragment, {\n        key: 1\n      }, [createCommentVNode(\" textarea \"), createElementVNode(\"textarea\", mergeProps({\n        ref_key: \"textarea\",\n        ref: textarea,\n        \"class\": unref(nsTextarea).e(\"inner\")\n      }, unref(attrs), {\n        tabindex: _ctx.tabindex,\n        disabled: unref(inputDisabled),\n        readonly: _ctx.readonly,\n        autocomplete: _ctx.autocomplete,\n        style: unref(textareaStyle),\n        \"aria-label\": _ctx.label,\n        placeholder: _ctx.placeholder,\n        onCompositionstart: handleCompositionStart,\n        onCompositionupdate: handleCompositionUpdate,\n        onCompositionend: handleCompositionEnd,\n        onInput: handleInput,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onKeydown: handleKeydown\n      }), null, 16, _hoisted_2), unref(isWordLimitVisible) ? (openBlock(), createElementBlock(\"span\", {\n        key: 0,\n        \"class\": normalizeClass(unref(nsInput).e(\"count\"))\n      }, toDisplayString(unref(textLength)) + \" / \" + toDisplayString(unref(attrs).maxlength), 3)) : createCommentVNode(\"v-if\", true)], 64))], 38)), [[vShow, _ctx.type !== \"hidden\"]]);\n    };\n  }\n}));\n\nvar Input = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue\"]]);\n\nexport { Input as default };","map":{"version":3,"mappings":"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","names":["suffix","prefix","validateIcon","passwordIcon","rawAttrs","props","textareaCalcStyle","resize","String","focused","minRows","calcTextareaHeight","minHeight","input2","target","calcIconOffset","value","event","isComposing","emit","nextTick","setNativeInputValue","handleInput","passwordVisible","focus","hovering","watch","resizeTextarea","updateIconOffset","innerPrefixRef","inputStyleInner","getSuffixOrPrefixWidth","paddingRight","paddingLeft","setInputPadding","onMounted","onUpdated","expose"],"sources":["../../../../../../packages/components/input/src/input.vue"],"sourcesContent":["<template>\n  <div\n    v-show=\"type !== 'hidden'\"\n    :class=\"[\n      type === 'textarea' ? nsTextarea.b() : nsInput.b(),\n      nsInput.m(inputSize),\n      nsInput.is('disabled', inputDisabled),\n      nsInput.is('exceed', inputExceed),\n      {\n        [nsInput.b('group')]: $slots.prepend || $slots.append,\n        [nsInput.bm('group', 'append')]: $slots.append,\n        [nsInput.bm('group', 'prepend')]: $slots.prepend,\n        [nsInput.m('prefix')]: $slots.prefix || prefixIcon,\n        [nsInput.m('suffix')]:\n          $slots.suffix || suffixIcon || clearable || showPassword,\n        [nsInput.m('suffix--password-clear')]: showClear && showPwdVisible,\n      },\n      $attrs.class,\n    ]\"\n    :style=\"containerStyle\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n  >\n    <!-- input -->\n    <template v-if=\"type !== 'textarea'\">\n      <!-- prepend slot -->\n      <div v-if=\"$slots.prepend\" :class=\"nsInput.be('group', 'prepend')\">\n        <slot name=\"prepend\" />\n      </div>\n\n      <input\n        ref=\"input\"\n        :class=\"nsInput.e('inner')\"\n        v-bind=\"attrs\"\n        :type=\"showPassword ? (passwordVisible ? 'text' : 'password') : type\"\n        :disabled=\"inputDisabled\"\n        :readonly=\"readonly\"\n        :autocomplete=\"autocomplete\"\n        :tabindex=\"tabindex\"\n        :aria-label=\"label\"\n        :placeholder=\"placeholder\"\n        :style=\"inputStyleInner\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n        @input=\"handleInput\"\n        @focus=\"handleFocus\"\n        @blur=\"handleBlur\"\n        @change=\"handleChange\"\n        @keydown=\"handleKeydown\"\n      />\n\n      <!-- prefix slot -->\n      <span v-if=\"$slots.prefix || prefixIcon\" :class=\"nsInput.e('prefix')\">\n        <span ref=\"innerPrefixRef\" :class=\"nsInput.e('prefix-inner')\">\n          <slot name=\"prefix\" />\n          <el-icon v-if=\"prefixIcon\" :class=\"nsInput.e('icon')\">\n            <component :is=\"prefixIcon\" />\n          </el-icon>\n        </span>\n      </span>\n\n      <!-- suffix slot -->\n      <span v-if=\"suffixVisible\" :class=\"nsInput.e('suffix')\">\n        <span ref=\"innerSuffixRef\" :class=\"nsInput.e('suffix-inner')\">\n          <template v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\">\n            <slot name=\"suffix\" />\n            <el-icon v-if=\"suffixIcon\" :class=\"nsInput.e('icon')\">\n              <component :is=\"suffixIcon\" />\n            </el-icon>\n          </template>\n          <el-icon\n            v-if=\"showClear\"\n            :class=\"[nsInput.e('icon'), nsInput.e('clear')]\"\n            @mousedown.prevent\n            @click=\"clear\"\n          >\n            <circle-close />\n          </el-icon>\n          <el-icon\n            v-if=\"showPwdVisible\"\n            :class=\"[nsInput.e('icon'), nsInput.e('clear')]\"\n            @click=\"handlePasswordVisible\"\n          >\n            <component :is=\"passwordIcon\" />\n          </el-icon>\n          <span v-if=\"isWordLimitVisible\" :class=\"nsInput.e('count')\">\n            <span :class=\"nsInput.e('count-inner')\">\n              {{ textLength }} / {{ attrs.maxlength }}\n            </span>\n          </span>\n        </span>\n        <el-icon\n          v-if=\"validateState && validateIcon && needStatusIcon\"\n          :class=\"[\n            nsInput.e('icon'),\n            nsInput.e('validateIcon'),\n            nsInput.is('loading', validateState === 'validating'),\n          ]\"\n        >\n          <component :is=\"validateIcon\" />\n        </el-icon>\n      </span>\n\n      <!-- append slot -->\n      <div v-if=\"$slots.append\" :class=\"nsInput.be('group', 'append')\">\n        <slot name=\"append\" />\n      </div>\n    </template>\n\n    <!-- textarea -->\n    <template v-else>\n      <textarea\n        ref=\"textarea\"\n        :class=\"nsTextarea.e('inner')\"\n        v-bind=\"attrs\"\n        :tabindex=\"tabindex\"\n        :disabled=\"inputDisabled\"\n        :readonly=\"readonly\"\n        :autocomplete=\"autocomplete\"\n        :style=\"textareaStyle\"\n        :aria-label=\"label\"\n        :placeholder=\"placeholder\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n        @input=\"handleInput\"\n        @focus=\"handleFocus\"\n        @blur=\"handleBlur\"\n        @change=\"handleChange\"\n        @keydown=\"handleKeydown\"\n      />\n      <span v-if=\"isWordLimitVisible\" :class=\"nsInput.e('count')\">\n        {{ textLength }} / {{ attrs.maxlength }}\n      </span>\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  getCurrentInstance,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  shallowRef,\n  toRef,\n  useAttrs as useRawAttrs,\n  useSlots,\n  watch,\n} from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { isNil } from 'lodash-unified'\nimport { ElIcon } from '@element-plus/components/icon'\nimport {\n  CircleClose,\n  Hide as IconHide,\n  View as IconView,\n} from '@element-plus/icons-vue'\nimport {\n  ValidateComponentsMap,\n  debugWarn,\n  isKorean,\n  isObject,\n} from '@element-plus/utils'\nimport {\n  useAttrs,\n  useDisabled,\n  useFormItem,\n  useNamespace,\n  useSize,\n} from '@element-plus/hooks'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { calcTextareaHeight } from './utils'\nimport { inputEmits, inputProps } from './input'\nimport type { CSSProperties, Ref, StyleValue } from 'vue'\n\ntype TargetElement = HTMLInputElement | HTMLTextAreaElement\nconst PENDANT_MAP = {\n  suffix: 'append',\n  prefix: 'prepend',\n} as const\n\ndefineOptions({\n  name: 'ElInput',\n  inheritAttrs: false,\n})\nconst props = defineProps(inputProps)\nconst emit = defineEmits(inputEmits)\n\nconst instance = getCurrentInstance()!\nconst rawAttrs = useRawAttrs()\nconst slots = useSlots()\n\nconst attrs = useAttrs()\nconst { form, formItem } = useFormItem()\nconst inputSize = useSize()\nconst inputDisabled = useDisabled()\nconst nsInput = useNamespace('input')\nconst nsTextarea = useNamespace('textarea')\n\nconst input = shallowRef<HTMLInputElement>()\nconst textarea = shallowRef<HTMLTextAreaElement>()\n\nconst focused = ref(false)\nconst hovering = ref(false)\nconst isComposing = ref(false)\nconst passwordVisible = ref(false)\nconst textareaCalcStyle = shallowRef(props.inputStyle)\n\nconst _ref = computed(() => input.value || textarea.value)\n\nconst needStatusIcon = computed(() => form?.statusIcon ?? false)\nconst validateState = computed(() => formItem?.validateState || '')\nconst validateIcon = computed(() => ValidateComponentsMap[validateState.value])\nconst passwordIcon = computed(() =>\n  passwordVisible.value ? IconView : IconHide\n)\nconst containerStyle = computed<StyleValue>(() => [\n  rawAttrs.style as StyleValue,\n  props.inputStyle,\n])\nconst textareaStyle = computed<StyleValue>(() => [\n  props.inputStyle,\n  textareaCalcStyle.value,\n  { resize: props.resize },\n])\nconst nativeInputValue = computed(() =>\n  isNil(props.modelValue) ? '' : String(props.modelValue)\n)\nconst showClear = computed(\n  () =>\n    props.clearable &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !!nativeInputValue.value &&\n    (focused.value || hovering.value)\n)\nconst showPwdVisible = computed(\n  () =>\n    props.showPassword &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    (!!nativeInputValue.value || focused.value)\n)\nconst isWordLimitVisible = computed(\n  () =>\n    props.showWordLimit &&\n    !!attrs.value.maxlength &&\n    (props.type === 'text' || props.type === 'textarea') &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !props.showPassword\n)\nconst textLength = computed(() => Array.from(nativeInputValue.value).length)\nconst inputExceed = computed(\n  () =>\n    // show exceed style if length of initial value greater then maxlength\n    !!isWordLimitVisible.value &&\n    textLength.value > Number(attrs.value.maxlength)\n)\nconst suffixVisible = computed(\n  () =>\n    !!slots.suffix ||\n    !!props.suffixIcon ||\n    showClear.value ||\n    props.showPassword ||\n    isWordLimitVisible.value ||\n    (!!validateState.value && needStatusIcon.value)\n)\n\nconst resizeTextarea = () => {\n  const { type, autosize } = props\n\n  if (!isClient || type !== 'textarea') return\n\n  if (autosize) {\n    const minRows = isObject(autosize) ? autosize.minRows : undefined\n    const maxRows = isObject(autosize) ? autosize.maxRows : undefined\n    textareaCalcStyle.value = {\n      ...calcTextareaHeight(textarea.value!, minRows, maxRows),\n    }\n  } else {\n    textareaCalcStyle.value = {\n      minHeight: calcTextareaHeight(textarea.value!).minHeight,\n    }\n  }\n}\n\nconst setNativeInputValue = () => {\n  const input = _ref.value\n  if (!input || input.value === nativeInputValue.value) return\n  input.value = nativeInputValue.value\n}\n\nconst calcIconOffset = (place: 'prefix' | 'suffix') => {\n  const { el } = instance.vnode\n  if (!el) return\n  const elList = Array.from(\n    (el as Element).querySelectorAll<HTMLSpanElement>(`.${nsInput.e(place)}`)\n  )\n  const target = elList.find((item) => item.parentNode === el)\n  if (!target) return\n\n  const pendant = PENDANT_MAP[place]\n\n  if (slots[pendant]) {\n    target.style.transform = `translateX(${place === 'suffix' ? '-' : ''}${\n      el.querySelector(`.${nsInput.be('group', pendant)}`).offsetWidth\n    }px)`\n  } else {\n    target.removeAttribute('style')\n  }\n}\n\nconst updateIconOffset = () => {\n  calcIconOffset('prefix')\n  calcIconOffset('suffix')\n}\n\nconst handleInput = async (event: Event) => {\n  const { value } = event.target as TargetElement\n\n  // should not emit input during composition\n  // see: https://github.com/ElemeFE/element/issues/10516\n  if (isComposing.value) return\n\n  // hack for https://github.com/ElemeFE/element/issues/8548\n  // should remove the following line when we don't support IE\n  if (value === nativeInputValue.value) return\n\n  emit(UPDATE_MODEL_EVENT, value)\n  emit('input', value)\n\n  // ensure native input value is controlled\n  // see: https://github.com/ElemeFE/element/issues/12850\n  await nextTick()\n  setNativeInputValue()\n}\n\nconst handleChange = (event: Event) => {\n  emit('change', (event.target as TargetElement).value)\n}\n\nconst handleCompositionStart = (event: CompositionEvent) => {\n  emit('compositionstart', event)\n  isComposing.value = true\n}\n\nconst handleCompositionUpdate = (event: CompositionEvent) => {\n  emit('compositionupdate', event)\n  const text = (event.target as HTMLInputElement)?.value\n  const lastCharacter = text[text.length - 1] || ''\n  isComposing.value = !isKorean(lastCharacter)\n}\n\nconst handleCompositionEnd = (event: CompositionEvent) => {\n  emit('compositionend', event)\n  if (isComposing.value) {\n    isComposing.value = false\n    handleInput(event)\n  }\n}\n\nconst handlePasswordVisible = () => {\n  passwordVisible.value = !passwordVisible.value\n  focus()\n}\n\nconst focus = async () => {\n  // see: https://github.com/ElemeFE/element/issues/18573\n  await nextTick()\n  _ref.value?.focus()\n}\n\nconst blur = () => _ref.value?.blur()\n\nconst handleFocus = (event: FocusEvent) => {\n  focused.value = true\n  emit('focus', event)\n}\n\nconst handleBlur = (event: FocusEvent) => {\n  focused.value = false\n  emit('blur', event)\n  if (props.validateEvent) {\n    formItem?.validate?.('blur').catch((err) => debugWarn(err))\n  }\n}\n\nconst handleMouseLeave = (evt: MouseEvent) => {\n  hovering.value = false\n  emit('mouseleave', evt)\n}\n\nconst handleMouseEnter = (evt: MouseEvent) => {\n  hovering.value = true\n  emit('mouseenter', evt)\n}\n\nconst handleKeydown = (evt: KeyboardEvent) => {\n  emit('keydown', evt)\n}\n\nconst select = () => {\n  _ref.value?.select()\n}\n\nconst clear = () => {\n  emit(UPDATE_MODEL_EVENT, '')\n  emit('change', '')\n  emit('clear')\n  emit('input', '')\n}\n\nwatch(\n  () => props.modelValue,\n  () => {\n    nextTick(() => resizeTextarea())\n    if (props.validateEvent) {\n      formItem?.validate?.('change').catch((err) => debugWarn(err))\n    }\n  }\n)\n\n// native input value is set explicitly\n// do not use v-model / :value in template\n// see: https://github.com/ElemeFE/element/issues/14521\nwatch(nativeInputValue, () => setNativeInputValue())\n\n// when change between <input> and <textarea>,\n// update DOM dependent value and styles\n// https://github.com/ElemeFE/element/issues/14857\nwatch(\n  () => props.type,\n  async () => {\n    await nextTick()\n    setNativeInputValue()\n    resizeTextarea()\n    updateIconOffset()\n  }\n)\n\n// Get the widths of 'suffix' and 'prefix' to set the padding property of the input\n// https://github.com/element-plus/element-plus/issues/6464\nconst innerSuffixRef = ref<HTMLElement>()\nconst innerPrefixRef = ref<HTMLElement>()\nconst inputStyleInner = ref<CSSProperties>({})\nconst getSuffixOrPrefixWidth = (\n  slotElm: Ref<HTMLElement>,\n  defaultVal: number\n): number => {\n  if (slotElm.value) {\n    const slotElmWidth = (slotElm.value as HTMLElement).offsetWidth\n    return slotElmWidth > 0 ? slotElmWidth + 16 : defaultVal\n  }\n  return defaultVal\n}\nconst setInputPadding = (): void => {\n  // If the user sets 'padding', use the 'padding' set by the user\n  inputStyleInner.value = {\n    paddingRight: `${getSuffixOrPrefixWidth(innerSuffixRef, 0)}px`,\n    paddingLeft: `${getSuffixOrPrefixWidth(innerPrefixRef, 11)}px`,\n    ...props.inputStyle,\n  }\n}\nwatch(showClear, () => {\n  nextTick(() => {\n    setInputPadding()\n  })\n})\n\nonMounted(async () => {\n  setInputPadding()\n  setNativeInputValue()\n  updateIconOffset()\n  await nextTick()\n  resizeTextarea()\n})\n\nonUpdated(async () => {\n  await nextTick()\n  updateIconOffset()\n})\n\ndefineExpose({\n  /** @description HTML input element */\n  input,\n  /** @description HTML textarea element */\n  textarea,\n  /** @description HTML element, input or textarea */\n  ref: _ref,\n  /** @description style of textarea. */\n  textareaStyle,\n\n  /** @description from props (used on unit test) */\n  autosize: toRef(props, 'autosize'),\n\n  /** @description HTML input element native method */\n  focus,\n  /** @description HTML input element native method */\n  blur,\n  /** @description HTML input element native method */\n  select,\n  /** @description clear input value */\n  clear,\n  /** @description resize textarea. */\n  resizeTextarea,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}