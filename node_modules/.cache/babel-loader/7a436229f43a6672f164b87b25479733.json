{"ast":null,"code":"import _typeof from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport '../../../../utils/index.mjs';\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE } from '../defaults.mjs';\nimport { throwError } from '../../../../utils/error.mjs';\nvar SCOPE = \"ElDynamicSizeList\";\n\nvar getItemFromCache = function getItemFromCache(props, index, listCache) {\n  var itemSize = props.itemSize;\n  var items = listCache.items,\n      lastVisitedIndex = listCache.lastVisitedIndex;\n\n  if (index > lastVisitedIndex) {\n    var offset = 0;\n\n    if (lastVisitedIndex >= 0) {\n      var item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n\n    for (var i = lastVisitedIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      items[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    listCache.lastVisitedIndex = index;\n  }\n\n  return items[index];\n};\n\nvar findItem = function findItem(props, listCache, offset) {\n  var items = listCache.items,\n      lastVisitedIndex = listCache.lastVisitedIndex;\n  var lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\n\nvar bs = function bs(props, listCache, low, high, offset) {\n  while (low <= high) {\n    var mid = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, listCache).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n\n  return Math.max(0, low - 1);\n};\n\nvar es = function es(props, listCache, index, offset) {\n  var total = props.total;\n  var exponent = 1;\n\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref, _ref2) {\n  var total = _ref.total;\n  var items = _ref2.items,\n      estimatedItemSize = _ref2.estimatedItemSize,\n      lastVisitedIndex = _ref2.lastVisitedIndex;\n  var totalSizeOfMeasuredItems = 0;\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n\n  if (lastVisitedIndex >= 0) {\n    var item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n\n  var numUnmeasuredItems = total - lastVisitedIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: function getItemOffset(props, index, listCache) {\n    return getItemFromCache(props, index, listCache).offset;\n  },\n  getItemSize: function getItemSize(_, index, _ref3) {\n    var items = _ref3.items;\n    return items[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffset: function getOffset(props, index, alignment, scrollOffset, listCache) {\n    var height = props.height,\n        layout = props.layout,\n        width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, index, listCache);\n    var estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    var minOffset = Math.max(0, item.offset - size + item.size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, listCache) {\n    return findItem(props, listCache, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, listCache) {\n    var height = props.height,\n        total = props.total,\n        layout = props.layout,\n        width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, startIndex, listCache);\n    var maxOffset = scrollOffset + size;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n\n    return stopIndex;\n  },\n  initCache: function initCache(_ref4, instance) {\n    var _ref4$estimatedItemSi = _ref4.estimatedItemSize,\n        estimatedItemSize = _ref4$estimatedItemSi === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref4$estimatedItemSi;\n    var cache = {\n      items: {},\n      estimatedItemSize: estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n\n    cache.clearCacheAfterIndex = function (index) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _a, _b;\n\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, \"\\n          itemSize is required as function, but the given value was \".concat(_typeof(itemSize), \"\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeList as default };","map":{"version":3,"mappings":";;;;;;AAWA,IAAMA,KAAK,GAAG,mBAAd;;AACA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,KAAD,EAAQC,KAAR,EAAeC,SAAf,EAA6B;AACpD,MAAQC,QAAR,GAAqBH,KAArB,CAAQG,QAAR;AACA,MAAQC,KAAR,GAAoCF,SAApC,CAAQE,KAAR;AAAA,MAAeC,gBAAf,GAAoCH,SAApC,CAAeG,gBAAf;;AACA,MAAIJ,KAAK,GAAGI,gBAAZ,EAA8B;AAC5B,QAAIC,MAAM,GAAG,CAAb;;AACA,QAAID,gBAAgB,IAAI,CAAxB,EAA2B;AACzB,UAAME,IAAI,GAAGH,KAAK,CAACC,gBAAD,CAAlB;AACAC,YAAM,GAAGC,IAAI,CAACD,MAAL,GAAcC,IAAI,CAACC,IAA5B;AACD;;AACD,SAAK,IAAIC,CAAC,GAAGJ,gBAAgB,GAAG,CAAhC,EAAmCI,CAAC,IAAIR,KAAxC,EAA+CQ,CAAC,EAAhD,EAAoD;AAClD,UAAMD,IAAI,GAAGL,QAAQ,CAACM,CAAD,CAArB;AACAL,WAAK,CAACK,CAAD,CAAL,GAAW;AACTH,cAAM,EAANA,MADS;AAETE,YAAI,EAAJA;AAFS,OAAX;AAIAF,YAAM,IAAIE,IAAV;AACD;;AACDN,aAAS,CAACG,gBAAV,GAA6BJ,KAA7B;AACD;;AACD,SAAOG,KAAK,CAACH,KAAD,CAAZ;AACD,CApBD;;AAqBA,IAAMS,QAAQ,GAAG,SAAXA,QAAW,CAACV,KAAD,EAAQE,SAAR,EAAmBI,MAAnB,EAA8B;AAC7C,MAAQF,KAAR,GAAoCF,SAApC,CAAQE,KAAR;AAAA,MAAeC,gBAAf,GAAoCH,SAApC,CAAeG,gBAAf;AACA,MAAMM,iBAAiB,GAAGN,gBAAgB,GAAG,CAAnB,GAAuBD,KAAK,CAACC,gBAAD,CAAL,CAAwBC,MAA/C,GAAwD,CAAlF;;AACA,MAAIK,iBAAiB,IAAIL,MAAzB,EAAiC;AAC/B,WAAOM,EAAE,CAACZ,KAAD,EAAQE,SAAR,EAAmB,CAAnB,EAAsBG,gBAAtB,EAAwCC,MAAxC,CAAT;AACD;;AACD,SAAOO,EAAE,CAACb,KAAD,EAAQE,SAAR,EAAmBY,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYV,gBAAZ,CAAnB,EAAkDC,MAAlD,CAAT;AACD,CAPD;;AAQA,IAAMM,EAAE,GAAG,SAALA,EAAK,CAACZ,KAAD,EAAQE,SAAR,EAAmBc,GAAnB,EAAwBC,IAAxB,EAA8BX,MAA9B,EAAyC;AAClD,SAAOU,GAAG,IAAIC,IAAd,EAAoB;AAClB,QAAMC,GAAG,GAAGF,GAAG,GAAGF,IAAI,CAACK,KAAL,CAAW,CAACF,IAAI,GAAGD,GAAR,IAAe,CAA1B,CAAlB;AACA,QAAMI,aAAa,GAAGrB,gBAAgB,CAACC,KAAD,EAAQkB,GAAR,EAAahB,SAAb,CAAhB,CAAwCI,MAA9D;;AACA,QAAIc,aAAa,KAAKd,MAAtB,EAA8B;AAC5B,aAAOY,GAAP;AACD,KAFD,MAEO,IAAIE,aAAa,GAAGd,MAApB,EAA4B;AACjCU,SAAG,GAAGE,GAAG,GAAG,CAAZ;AACD,KAFM,MAEA,IAAIE,aAAa,GAAGd,MAApB,EAA4B;AACjCW,UAAI,GAAGC,GAAG,GAAG,CAAb;AACD;AACF;;AACD,SAAOJ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYC,GAAG,GAAG,CAAlB,CAAP;AACD,CAbD;;AAcA,IAAMH,EAAE,GAAG,SAALA,EAAK,CAACb,KAAD,EAAQE,SAAR,EAAmBD,KAAnB,EAA0BK,MAA1B,EAAqC;AAC9C,MAAQe,KAAR,GAAkBrB,KAAlB,CAAQqB,KAAR;AACA,MAAIC,QAAQ,GAAG,CAAf;;AACA,SAAOrB,KAAK,GAAGoB,KAAR,IAAiBtB,gBAAgB,CAACC,KAAD,EAAQC,KAAR,EAAeC,SAAf,CAAhB,CAA0CI,MAA1C,GAAmDA,MAA3E,EAAmF;AACjFL,SAAK,IAAIqB,QAAT;AACAA,YAAQ,IAAI,CAAZ;AACD;;AACD,SAAOV,EAAE,CAACZ,KAAD,EAAQE,SAAR,EAAmBY,IAAI,CAACK,KAAL,CAAWlB,KAAK,GAAG,CAAnB,CAAnB,EAA0Ca,IAAI,CAACS,GAAL,CAAStB,KAAT,EAAgBoB,KAAK,GAAG,CAAxB,CAA1C,EAAsEf,MAAtE,CAAT;AACD,CARD;;AASA,IAAMkB,qBAAqB,GAAG,SAAxBA,qBAAwB,cAA+D;AAAA,MAA5DH,KAA4D,QAA5DA,KAA4D;AAAA,MAAjDjB,KAAiD,SAAjDA,KAAiD;AAAA,MAA1CqB,iBAA0C,SAA1CA,iBAA0C;AAAA,MAAvBpB,gBAAuB,SAAvBA,gBAAuB;AAC3F,MAAIqB,wBAAwB,GAAG,CAA/B;;AACA,MAAIrB,gBAAgB,IAAIgB,KAAxB,EAA+B;AAC7BhB,oBAAgB,GAAGgB,KAAK,GAAG,CAA3B;AACD;;AACD,MAAIhB,gBAAgB,IAAI,CAAxB,EAA2B;AACzB,QAAME,IAAI,GAAGH,KAAK,CAACC,gBAAD,CAAlB;AACAqB,4BAAwB,GAAGnB,IAAI,CAACD,MAAL,GAAcC,IAAI,CAACC,IAA9C;AACD;;AACD,MAAMmB,kBAAkB,GAAGN,KAAK,GAAGhB,gBAAR,GAA2B,CAAtD;AACA,MAAMuB,0BAA0B,GAAGD,kBAAkB,GAAGF,iBAAxD;AACA,SAAOC,wBAAwB,GAAGE,0BAAlC;AACD,CAZD;;AAaK,IAACC,eAAe,GAAGC,UAAU,CAAC;AACjCC,MAAI,EAAE,mBAD2B;AAEjCC,eAAa,EAAE,uBAAChC,KAAD,EAAQC,KAAR,EAAeC,SAAf;AAAA,WAA6BH,gBAAgB,CAACC,KAAD,EAAQC,KAAR,EAAeC,SAAf,CAAhB,CAA0CI,MAAvE;AAAA,GAFkB;AAGjC2B,aAAW,EAAE,qBAACC,CAAD,EAAIjC,KAAJ;AAAA,QAAaG,KAAb,SAAaA,KAAb;AAAA,WAAyBA,KAAK,CAACH,KAAD,CAAL,CAAaO,IAAtC;AAAA,GAHoB;AAIjCgB,uBAAqB,EAArBA,qBAJiC;AAKjCW,WAAS,EAAE,mBAACnC,KAAD,EAAQC,KAAR,EAAemC,SAAf,EAA0BC,YAA1B,EAAwCnC,SAAxC,EAAsD;AAC/D,QAAQoC,MAAR,GAAkCtC,KAAlC,CAAQsC,MAAR;AAAA,QAAgBC,MAAhB,GAAkCvC,KAAlC,CAAgBuC,MAAhB;AAAA,QAAwBC,KAAxB,GAAkCxC,KAAlC,CAAwBwC,KAAxB;AACA,QAAMhC,IAAI,GAAGiC,YAAY,CAACF,MAAD,CAAZ,GAAuBC,KAAvB,GAA+BF,MAA5C;AACA,QAAM/B,IAAI,GAAGR,gBAAgB,CAACC,KAAD,EAAQC,KAAR,EAAeC,SAAf,CAA7B;AACA,QAAMwC,kBAAkB,GAAGlB,qBAAqB,CAACxB,KAAD,EAAQE,SAAR,CAAhD;AACA,QAAMyC,SAAS,GAAG7B,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACS,GAAL,CAASmB,kBAAkB,GAAGlC,IAA9B,EAAoCD,IAAI,CAACD,MAAzC,CAAZ,CAAlB;AACA,QAAMsC,SAAS,GAAG9B,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYR,IAAI,CAACD,MAAL,GAAcE,IAAd,GAAqBD,IAAI,CAACC,IAAtC,CAAlB;;AACA,QAAI4B,SAAS,KAAKS,eAAlB,EAAmC;AACjC,UAAIR,YAAY,IAAIO,SAAS,GAAGpC,IAA5B,IAAoC6B,YAAY,IAAIM,SAAS,GAAGnC,IAApE,EAA0E;AACxE4B,iBAAS,GAAGU,cAAZ;AACD,OAFD,MAEO;AACLV,iBAAS,GAAGW,kBAAZ;AACD;AACF;;AACD,YAAQX,SAAR;AACE,WAAKY,eAAL;AAAsB;AACpB,iBAAOL,SAAP;AACD;;AACD,WAAKM,aAAL;AAAoB;AAClB,iBAAOL,SAAP;AACD;;AACD,WAAKG,kBAAL;AAAyB;AACvB,iBAAOjC,IAAI,CAACoC,KAAL,CAAWN,SAAS,GAAG,CAACD,SAAS,GAAGC,SAAb,IAA0B,CAAjD,CAAP;AACD;;AACD,WAAKE,cAAL;AACA;AAAS;AACP,cAAIT,YAAY,IAAIO,SAAhB,IAA6BP,YAAY,IAAIM,SAAjD,EAA4D;AAC1D,mBAAON,YAAP;AACD,WAFD,MAEO,IAAIA,YAAY,GAAGO,SAAnB,EAA8B;AACnC,mBAAOA,SAAP;AACD,WAFM,MAEA;AACL,mBAAOD,SAAP;AACD;AACF;AAnBH;AAqBD,GAxCgC;AAyCjCQ,wBAAsB,EAAE,gCAACnD,KAAD,EAAQM,MAAR,EAAgBJ,SAAhB;AAAA,WAA8BQ,QAAQ,CAACV,KAAD,EAAQE,SAAR,EAAmBI,MAAnB,CAAtC;AAAA,GAzCS;AA0CjC8C,2BAAyB,EAAE,mCAACpD,KAAD,EAAQqD,UAAR,EAAoBhB,YAApB,EAAkCnC,SAAlC,EAAgD;AACzE,QAAQoC,MAAR,GAAyCtC,KAAzC,CAAQsC,MAAR;AAAA,QAAgBjB,KAAhB,GAAyCrB,KAAzC,CAAgBqB,KAAhB;AAAA,QAAuBkB,MAAvB,GAAyCvC,KAAzC,CAAuBuC,MAAvB;AAAA,QAA+BC,KAA/B,GAAyCxC,KAAzC,CAA+BwC,KAA/B;AACA,QAAMhC,IAAI,GAAGiC,YAAY,CAACF,MAAD,CAAZ,GAAuBC,KAAvB,GAA+BF,MAA5C;AACA,QAAM/B,IAAI,GAAGR,gBAAgB,CAACC,KAAD,EAAQqD,UAAR,EAAoBnD,SAApB,CAA7B;AACA,QAAMyC,SAAS,GAAGN,YAAY,GAAG7B,IAAjC;AACA,QAAIF,MAAM,GAAGC,IAAI,CAACD,MAAL,GAAcC,IAAI,CAACC,IAAhC;AACA,QAAI8C,SAAS,GAAGD,UAAhB;;AACA,WAAOC,SAAS,GAAGjC,KAAK,GAAG,CAApB,IAAyBf,MAAM,GAAGqC,SAAzC,EAAoD;AAClDW,eAAS;AACThD,YAAM,IAAIP,gBAAgB,CAACC,KAAD,EAAQsD,SAAR,EAAmBpD,SAAnB,CAAhB,CAA8CM,IAAxD;AACD;;AACD,WAAO8C,SAAP;AACD,GAtDgC;AAuDjCC,WAvDiC,4BAuDiCC,QAvDjC,EAuD2C;AAAA,sCAAhE/B,iBAAgE;AAAA,QAAhEA,iBAAgE,sCAA5CgC,8BAA4C;AAC1E,QAAMC,KAAK,GAAG;AACZtD,WAAK,EAAE,EADK;AAEZqB,uBAAiB,EAAjBA,iBAFY;AAGZpB,sBAAgB,EAAE,CAAC;AAHP,KAAd;;AAKAqD,SAAK,CAACC,oBAAN,GAA6B,UAAC1D,KAAD,EAA+B;AAAA,UAAvB2D,WAAuB,uEAAT,IAAS;;AAC1D,UAAIC,EAAJ,EAAQC,EAAR;;AACAJ,WAAK,CAACrD,gBAAN,GAAyBS,IAAI,CAACS,GAAL,CAASmC,KAAK,CAACrD,gBAAf,EAAiCJ,KAAK,GAAG,CAAzC,CAAzB;AACA,OAAC4D,EAAE,GAAGL,QAAQ,CAACO,OAAf,KAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2CF,EAAE,CAACG,iBAAH,CAAqB,CAAC,CAAtB,CAA3C;;AACA,UAAIJ,WAAJ,EAAiB;AACf,SAACE,EAAE,GAAGN,QAAQ,CAACS,KAAf,KAAyB,IAAzB,GAAgC,KAAK,CAArC,GAAyCH,EAAE,CAACI,YAAH,EAAzC;AACD;AACF,KAPD;;AAQA,WAAOR,KAAP;AACD,GAtEgC;AAuEjCS,YAAU,EAAE,KAvEqB;AAwEjCC,eAAa,EAAE,8BAAkB;AAAA,QAAfjE,QAAe,SAAfA,QAAe;;AAC/B,QAAIkE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,UAAI,OAAOpE,QAAP,KAAoB,UAAxB,EAAoC;AAClCqE,kBAAU,CAAC1E,KAAD,0FAC2DK,QAD3D,iBAAV;AAGD;AACF;AACF;AAhFgC,CAAD,CAA7B","names":["SCOPE","getItemFromCache","props","index","listCache","itemSize","items","lastVisitedIndex","offset","item","size","i","findItem","lastVisitedOffset","bs","es","Math","max","low","high","mid","floor","currentOffset","total","exponent","min","getEstimatedTotalSize","estimatedItemSize","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","createList","name","getItemOffset","getItemSize","_","getOffset","alignment","scrollOffset","height","layout","width","isHorizontal","estimatedTotalSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","getStartIndexForOffset","getStopIndexForStartIndex","startIndex","stopIndex","initCache","instance","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","cache","clearCacheAfterIndex","forceUpdate","_a","_b","exposed","getItemStyleCache","proxy","$forceUpdate","clearCache","validateProps","process","env","NODE_ENV","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-list.ts"],"sourcesContent":["import { throwError } from '@element-plus/utils'\n\nimport createList from '../builders/build-list'\n\nimport { isHorizontal } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { VirtualizedListProps } from '../props'\n\nimport type { ItemSize, ListCache, ListItem } from '../types'\n\ntype Props = VirtualizedListProps\n\nconst SCOPE = 'ElDynamicSizeList'\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  listCache: ListCache\n): ListItem => {\n  const { itemSize } = props\n  const { items, lastVisitedIndex } = listCache\n\n  if (index > lastVisitedIndex) {\n    let offset = 0\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = (itemSize as ItemSize)(i)\n\n      items[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    listCache.lastVisitedIndex = index\n  }\n\n  return items[index]\n}\n\nconst findItem = (props: Props, listCache: ListCache, offset: number) => {\n  const { items, lastVisitedIndex } = listCache\n\n  const lastVisitedOffset =\n    lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset)\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset)\n}\n\n// bs stands for binary search which has approximately time complexity of O(Log n)\n// space complexity of O(1)\n// in this case we use it for search the offset of each item, since\n// the cached items' offset is monotonically increasing\nconst bs = (\n  props: Props,\n  listCache: ListCache,\n  low: number,\n  high: number,\n  offset: number\n) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, listCache).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else if (currentOffset > offset) {\n      high = mid - 1\n    }\n  }\n\n  return Math.max(0, low - 1)\n}\n\n// es stands for exponential search which has time complexity of O(Log n) and\n// space complexity of O(1) in the case of finding the boundary element.\n// the exponential indicator in this case is 2.\n// for more detail about exponential search click this link\n// https://www.freecodecamp.org/news/search-algorithms-exponential-search-explained/\n\nconst es = (\n  props: Props,\n  listCache: ListCache,\n  index: number,\n  offset: number\n) => {\n  const { total } = props\n  let exponent = 1\n\n  while (\n    index < total &&\n    getItemFromCache(props, index, listCache).offset < offset\n  ) {\n    index += exponent\n    exponent *= 2\n  }\n\n  return bs(\n    props,\n    listCache,\n    Math.floor(index / 2),\n    Math.min(index, total - 1),\n    offset\n  )\n}\n\nconst getEstimatedTotalSize = (\n  { total }: Props,\n  { items, estimatedItemSize, lastVisitedIndex }: ListCache\n) => {\n  let totalSizeOfMeasuredItems = 0\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex]\n    totalSizeOfMeasuredItems = item.offset + item.size\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems\n}\n\nconst DynamicSizeList = createList({\n  name: 'ElDynamicSizeList',\n  getItemOffset: (props, index, listCache) =>\n    getItemFromCache(props, index, listCache).offset,\n\n  getItemSize: (_, index, { items }) => items[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, index, listCache)\n\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache)\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, item.offset)\n    )\n    const minOffset = Math.max(0, item.offset - size + item.size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2)\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: (props, offset, listCache) =>\n    findItem(props, listCache, offset),\n\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, startIndex, listCache)\n    const maxOffset = scrollOffset + size\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, listCache).size\n    }\n\n    return stopIndex\n  },\n\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1,\n    } as ListCache\n\n    cache.clearCacheAfterIndex = (index: number, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1)\n      instance.exposed?.getItemStyleCache(-1)\n\n      if (forceUpdate) {\n        instance.proxy?.$forceUpdate()\n      }\n    }\n\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throwError(\n          SCOPE,\n          `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default DynamicSizeList\n"]},"metadata":{},"sourceType":"module"}