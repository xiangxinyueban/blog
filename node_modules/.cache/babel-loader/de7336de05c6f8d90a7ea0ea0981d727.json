{"ast":null,"code":"import \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport { computed } from 'vue';\n\nvar useMarks = function useMarks(props) {\n  return computed(function () {\n    if (!props.marks) {\n      return [];\n    }\n\n    var marksKeys = Object.keys(props.marks);\n    return marksKeys.map(parseFloat).sort(function (a, b) {\n      return a - b;\n    }).filter(function (point) {\n      return point <= props.max && point >= props.min;\n    }).map(function (point) {\n      return {\n        point: point,\n        position: (point - props.min) * 100 / (props.max - props.min),\n        mark: props.marks[point]\n      };\n    });\n  });\n};\n\nexport { useMarks };","map":{"version":3,"mappings":";;;;;;;;AACY,IAACA,QAAQ,GAAG,SAAXA,QAAW,CAACC,KAAD,EAAW;AACjC,SAAOC,QAAQ,CAAC,YAAM;AACpB,QAAI,CAACD,KAAK,CAACE,KAAX,EAAkB;AAChB,aAAO,EAAP;AACD;;AACD,QAAMC,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYL,KAAK,CAACE,KAAlB,CAAlB;AACA,WAAOC,SAAS,CAACG,GAAV,CAAcC,UAAd,EAA0BC,IAA1B,CAA+B,UAACC,CAAD,EAAIC,CAAJ;AAAA,aAAUD,CAAC,GAAGC,CAAd;AAAA,KAA/B,EAAgDC,MAAhD,CAAuD,UAACC,KAAD;AAAA,aAAWA,KAAK,IAAIZ,KAAK,CAACa,GAAf,IAAsBD,KAAK,IAAIZ,KAAK,CAACc,GAAhD;AAAA,KAAvD,EAA4GR,GAA5G,CAAgH,UAACM,KAAD;AAAA,aAAY;AACjIA,aAAK,EAALA,KADiI;AAEjIG,gBAAQ,EAAE,CAACH,KAAK,GAAGZ,KAAK,CAACc,GAAf,IAAsB,GAAtB,IAA6Bd,KAAK,CAACa,GAAN,GAAYb,KAAK,CAACc,GAA/C,CAFuH;AAGjIE,YAAI,EAAEhB,KAAK,CAACE,KAAN,CAAYU,KAAZ;AAH2H,OAAZ;AAAA,KAAhH,CAAP;AAKD,GAVc,CAAf;AAWF,CAZY","names":["useMarks","props","computed","marks","marksKeys","Object","keys","map","parseFloat","sort","a","b","filter","point","max","min","position","mark"],"sources":["../../../../../../packages/components/slider/src/useMarks.ts"],"sourcesContent":["import { computed } from 'vue'\nimport type { ISliderProps, Mark } from './slider.type'\n\nexport const useMarks = (props: ISliderProps) => {\n  return computed(() => {\n    if (!props.marks) {\n      return []\n    }\n\n    const marksKeys = Object.keys(props.marks)\n    return marksKeys\n      .map(parseFloat)\n      .sort((a, b) => a - b)\n      .filter((point) => point <= props.max && point >= props.min)\n      .map(\n        (point): Mark => ({\n          point,\n          position: ((point - props.min) * 100) / (props.max - props.min),\n          mark: props.marks[point],\n        })\n      )\n  })\n}\n"]},"metadata":{},"sourceType":"module"}