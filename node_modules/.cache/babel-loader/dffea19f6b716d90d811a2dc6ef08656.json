{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/PartTimeJob/blog/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { ref, getCurrentInstance, watch, nextTick } from 'vue';\nimport { SetOperationEnum, NODE_CHECK, NODE_CHECK_CHANGE } from '../virtual-tree.mjs';\n\nfunction useCheck(props, tree) {\n  var checkedKeys = ref( /* @__PURE__ */new Set());\n  var indeterminateKeys = ref( /* @__PURE__ */new Set());\n\n  var _getCurrentInstance = getCurrentInstance(),\n      emit = _getCurrentInstance.emit;\n\n  watch(function () {\n    return tree.value;\n  }, function () {\n    return nextTick(function () {\n      _setCheckedKeys(props.defaultCheckedKeys);\n    });\n  }, {\n    immediate: true\n  });\n\n  var updateCheckedKeys = function updateCheckedKeys() {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return;\n    }\n\n    var _tree$value = tree.value,\n        levelTreeNodeMap = _tree$value.levelTreeNodeMap,\n        maxLevel = _tree$value.maxLevel;\n    var checkedKeySet = checkedKeys.value;\n    var indeterminateKeySet = /* @__PURE__ */new Set();\n\n    for (var level = maxLevel - 1; level >= 1; --level) {\n      var nodes = levelTreeNodeMap.get(level);\n      if (!nodes) continue;\n      nodes.forEach(function (node) {\n        var children = node.children;\n\n        if (children) {\n          var allChecked = true;\n          var hasChecked = false;\n\n          var _iterator = _createForOfIteratorHelper(children),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var childNode = _step.value;\n              var key = childNode.key;\n\n              if (checkedKeySet.has(key)) {\n                hasChecked = true;\n              } else if (indeterminateKeySet.has(key)) {\n                allChecked = false;\n                hasChecked = true;\n                break;\n              } else {\n                allChecked = false;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          if (allChecked) {\n            checkedKeySet.add(node.key);\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key);\n            checkedKeySet[\"delete\"](node.key);\n          } else {\n            checkedKeySet[\"delete\"](node.key);\n            indeterminateKeySet[\"delete\"](node.key);\n          }\n        }\n      });\n    }\n\n    indeterminateKeys.value = indeterminateKeySet;\n  };\n\n  var isChecked = function isChecked(node) {\n    return checkedKeys.value.has(node.key);\n  };\n\n  var isIndeterminate = function isIndeterminate(node) {\n    return indeterminateKeys.value.has(node.key);\n  };\n\n  var toggleCheckbox = function toggleCheckbox(node, isChecked2) {\n    var nodeClick = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var checkedKeySet = checkedKeys.value;\n\n    var toggle = function toggle(node2, checked) {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);\n      var children = node2.children;\n\n      if (!props.checkStrictly && children) {\n        children.forEach(function (childNode) {\n          if (!childNode.disabled) {\n            toggle(childNode, checked);\n          }\n        });\n      }\n    };\n\n    toggle(node, isChecked2);\n    updateCheckedKeys();\n\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked2);\n    }\n  };\n\n  var afterNodeCheck = function afterNodeCheck(node, checked) {\n    var _getChecked = getChecked(),\n        checkedNodes = _getChecked.checkedNodes,\n        checkedKeys2 = _getChecked.checkedKeys;\n\n    var _getHalfChecked = getHalfChecked(),\n        halfCheckedNodes = _getHalfChecked.halfCheckedNodes,\n        halfCheckedKeys = _getHalfChecked.halfCheckedKeys;\n\n    emit(NODE_CHECK, node.data, {\n      checkedKeys: checkedKeys2,\n      checkedNodes: checkedNodes,\n      halfCheckedKeys: halfCheckedKeys,\n      halfCheckedNodes: halfCheckedNodes\n    });\n    emit(NODE_CHECK_CHANGE, node.data, checked);\n  };\n\n  function getCheckedKeys() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return getChecked(leafOnly).checkedKeys;\n  }\n\n  function getCheckedNodes() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return getChecked(leafOnly).checkedNodes;\n  }\n\n  function getHalfCheckedKeys() {\n    return getHalfChecked().halfCheckedKeys;\n  }\n\n  function getHalfCheckedNodes() {\n    return getHalfChecked().halfCheckedNodes;\n  }\n\n  function getChecked() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var checkedNodes = [];\n    var keys = [];\n\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      checkedKeys.value.forEach(function (key) {\n        var node = treeNodeMap.get(key);\n\n        if (node && (!leafOnly || leafOnly && node.isLeaf)) {\n          keys.push(key);\n          checkedNodes.push(node.data);\n        }\n      });\n    }\n\n    return {\n      checkedKeys: keys,\n      checkedNodes: checkedNodes\n    };\n  }\n\n  function getHalfChecked() {\n    var halfCheckedNodes = [];\n    var halfCheckedKeys = [];\n\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      indeterminateKeys.value.forEach(function (key) {\n        var node = treeNodeMap.get(key);\n\n        if (node) {\n          halfCheckedKeys.push(key);\n          halfCheckedNodes.push(node.data);\n        }\n      });\n    }\n\n    return {\n      halfCheckedNodes: halfCheckedNodes,\n      halfCheckedKeys: halfCheckedKeys\n    };\n  }\n\n  function setCheckedKeys(keys) {\n    checkedKeys.value.clear();\n    indeterminateKeys.value.clear();\n\n    _setCheckedKeys(keys);\n  }\n\n  function setChecked(key, isChecked2) {\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var node = tree.value.treeNodeMap.get(key);\n\n      if (node) {\n        toggleCheckbox(node, isChecked2, false);\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys) {\n    if (tree == null ? void 0 : tree.value) {\n      var treeNodeMap = tree.value.treeNodeMap;\n\n      if (props.showCheckbox && treeNodeMap && keys) {\n        var _iterator2 = _createForOfIteratorHelper(keys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n            var node = treeNodeMap.get(key);\n\n            if (node && !isChecked(node)) {\n              toggleCheckbox(node, true, false);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys: updateCheckedKeys,\n    toggleCheckbox: toggleCheckbox,\n    isChecked: isChecked,\n    isIndeterminate: isIndeterminate,\n    getCheckedKeys: getCheckedKeys,\n    getCheckedNodes: getCheckedNodes,\n    getHalfCheckedKeys: getHalfCheckedKeys,\n    getHalfCheckedNodes: getHalfCheckedNodes,\n    setChecked: setChecked,\n    setCheckedKeys: setCheckedKeys\n  };\n}\n\nexport { useCheck };","map":{"version":3,"mappings":"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","names":["useCheck","props","tree","checkedKeys","ref","Set","indeterminateKeys","getCurrentInstance","emit","watch","value","nextTick","_setCheckedKeys","defaultCheckedKeys","immediate","updateCheckedKeys","showCheckbox","checkStrictly","levelTreeNodeMap","maxLevel","checkedKeySet","indeterminateKeySet","level","nodes","get","forEach","node","children","allChecked","hasChecked","childNode","key","has","add","isChecked","isIndeterminate","toggleCheckbox","isChecked2","nodeClick","toggle","node2","checked","SetOperationEnum","ADD","DELETE","disabled","afterNodeCheck","getChecked","checkedNodes","checkedKeys2","getHalfChecked","halfCheckedNodes","halfCheckedKeys","NODE_CHECK","data","NODE_CHECK_CHANGE","getCheckedKeys","leafOnly","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","keys","treeNodeMap","isLeaf","push","setCheckedKeys","clear","setChecked"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useCheck.ts"],"sourcesContent":["import { getCurrentInstance, nextTick, ref, watch } from 'vue'\nimport {\n  NODE_CHECK,\n  NODE_CHECK_CHANGE,\n  SetOperationEnum,\n} from '../virtual-tree'\nimport type { Ref } from 'vue'\nimport type { Tree, TreeKey, TreeNode, TreeNodeData, TreeProps } from '../types'\n\nexport function useCheck(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const checkedKeys = ref<Set<TreeKey>>(new Set())\n  const indeterminateKeys = ref<Set<TreeKey>>(new Set())\n  const { emit } = getCurrentInstance()!\n\n  watch(\n    () => tree.value,\n    () => {\n      return nextTick(() => {\n        _setCheckedKeys(props.defaultCheckedKeys)\n      })\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return\n    }\n    const { levelTreeNodeMap, maxLevel } = tree.value\n    const checkedKeySet = checkedKeys.value\n    const indeterminateKeySet = new Set<TreeKey>()\n    // It is easier to determine the indeterminate state by\n    // traversing from bottom to top\n    // leaf nodes not have indeterminate status and can be skipped\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level)\n      if (!nodes) continue\n      nodes.forEach((node) => {\n        const children = node.children\n        if (children) {\n          // Whether all child nodes are selected\n          let allChecked = true\n          // Whether a child node is selected\n          let hasChecked = false\n          for (const childNode of children) {\n            const key = childNode.key\n            if (checkedKeySet.has(key)) {\n              hasChecked = true\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false\n              hasChecked = true\n              break\n            } else {\n              allChecked = false\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key)\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key)\n            checkedKeySet.delete(node.key)\n          } else {\n            checkedKeySet.delete(node.key)\n            indeterminateKeySet.delete(node.key)\n          }\n        }\n      })\n    }\n    indeterminateKeys.value = indeterminateKeySet\n  }\n\n  const isChecked = (node: TreeNode) => checkedKeys.value.has(node.key)\n\n  const isIndeterminate = (node: TreeNode) =>\n    indeterminateKeys.value.has(node.key)\n\n  const toggleCheckbox = (\n    node: TreeNode,\n    isChecked: boolean,\n    nodeClick = true\n  ) => {\n    const checkedKeySet = checkedKeys.value\n    const toggle = (node: TreeNode, checked: boolean) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](\n        node.key\n      )\n      const children = node.children\n      if (!props.checkStrictly && children) {\n        children.forEach((childNode) => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked)\n          }\n        })\n      }\n    }\n    toggle(node, isChecked)\n    updateCheckedKeys()\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked)\n    }\n  }\n\n  const afterNodeCheck = (node: TreeNode, checked: boolean) => {\n    const { checkedNodes, checkedKeys } = getChecked()\n    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked()\n    emit(NODE_CHECK, node.data, {\n      checkedKeys,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes,\n    })\n    emit(NODE_CHECK_CHANGE, node.data, checked)\n  }\n\n  // expose\n  function getCheckedKeys(leafOnly = false): TreeKey[] {\n    return getChecked(leafOnly).checkedKeys\n  }\n\n  function getCheckedNodes(leafOnly = false): TreeNodeData[] {\n    return getChecked(leafOnly).checkedNodes\n  }\n\n  function getHalfCheckedKeys(): TreeKey[] {\n    return getHalfChecked().halfCheckedKeys\n  }\n\n  function getHalfCheckedNodes(): TreeNodeData[] {\n    return getHalfChecked().halfCheckedNodes\n  }\n\n  function getChecked(leafOnly = false): {\n    checkedKeys: TreeKey[]\n    checkedNodes: TreeNodeData[]\n  } {\n    const checkedNodes: TreeNodeData[] = []\n    const keys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      checkedKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && (!leafOnly || (leafOnly && node.isLeaf))) {\n          keys.push(key)\n          checkedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes,\n    }\n  }\n\n  function getHalfChecked(): {\n    halfCheckedKeys: TreeKey[]\n    halfCheckedNodes: TreeNodeData[]\n  } {\n    const halfCheckedNodes: TreeNodeData[] = []\n    const halfCheckedKeys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      indeterminateKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node) {\n          halfCheckedKeys.push(key)\n          halfCheckedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys,\n    }\n  }\n\n  function setCheckedKeys(keys: TreeKey[]) {\n    checkedKeys.value.clear()\n    indeterminateKeys.value.clear()\n    _setCheckedKeys(keys)\n  }\n\n  function setChecked(key: TreeKey, isChecked: boolean) {\n    if (tree?.value && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key)\n      if (node) {\n        toggleCheckbox(node, isChecked, false)\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys: TreeKey[]) {\n    if (tree?.value) {\n      const { treeNodeMap } = tree.value\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (const key of keys) {\n          const node = treeNodeMap.get(key)\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false)\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    // expose\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}